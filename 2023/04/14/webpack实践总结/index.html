<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>webpack 实践总结 | JSON的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、webpack 原理1、概念 webpack 是一个用于现代 JavaScript 应用程序的 _静态模块打包工具_。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 _bundles_，它们均为静态资源，用于展示你的内容。  也就是将各种类型的资源，包括图片、css、js 等，">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack 实践总结">
<meta property="og:url" content="https://jasonchan27.github.io/2023/04/14/webpack%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="JSON的笔记">
<meta property="og:description" content="一、webpack 原理1、概念 webpack 是一个用于现代 JavaScript 应用程序的 _静态模块打包工具_。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 _bundles_，它们均为静态资源，用于展示你的内容。  也就是将各种类型的资源，包括图片、css、js 等，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/webpack-concept.jpg">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/webpack-flow-chart.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/webpack-resource.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/module-graph.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/module-graph-demo.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/tapable%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/compiler-hook.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/compilation-hook.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/loader-pitch.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/loader-pitch-interapt.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/640.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/642.png">
<meta property="og:image" content="https://jasonchan27.github.io/images/23-4-14/640.png">
<meta property="article:published_time" content="2023-04-14T10:55:00.000Z">
<meta property="article:modified_time" content="2023-04-14T11:01:42.427Z">
<meta property="article:author" content="Jason Chan">
<meta property="article:tag" content="前端实践">
<meta property="article:tag" content="webpack">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonchan27.github.io/images/23-4-14/webpack-concept.jpg">
  
    <link rel="alternate" href="/atom.xml" title="JSON的笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JSON的笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录想分享的瞬间、前端技术</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jasonchan27.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-webpack实践总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/14/webpack%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-04-14T10:55:00.000Z" itemprop="datePublished">2023-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      webpack 实践总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、webpack-原理"><a href="#一、webpack-原理" class="headerlink" title="一、webpack 原理"></a>一、webpack 原理</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><strong>1</strong>、概念</h3><blockquote>
<p><strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 _静态模块打包工具_。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 _bundles_，它们均为静态资源，用于展示你的内容。</p>
</blockquote>
<p>也就是将各种类型的资源，包括图片、css、js 等，转译、组合、拼接、生成 JS 格式的 bundler 文件，官网首页的动画很形象地表达了这一点：</p>
<p><img src="/./images/23-4-14/webpack-concept.jpg" alt="webpack-concept"></p>
<span id="more"></span>

<h3 id="2、核心流程"><a href="#2、核心流程" class="headerlink" title="2、核心流程"></a>2、核心流程</h3><p>webpack 的执行过程核心完成了内容转换和资源合并两种功能，实现上可包含三个阶段：初始化阶段、构建阶段、生成阶段。如下图所示：</p>
<p><img src="/./images/23-4-14/webpack-flow-chart.png" alt="webpack-flow-chart"></p>
<h5 id="i-初始化阶段"><a href="#i-初始化阶段" class="headerlink" title="i. 初始化阶段"></a>i. 初始化阶段</h5><ol>
<li><p><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数：</p>
<ul>
<li><p>将 <code>process.args + webpack.config.js</code> 合并成用户配置</p>
</li>
<li><p>调用 <code>validateSchema</code> 校验配置</p>
</li>
<li><p>调用 <code>getNormalizedWebpackOptions + applyWebpackOptionsBaseDefaults</code> 合并出最终配置</p>
</li>
</ul>
</li>
<li><p><strong>创建编译器对象</strong>：用上一步得到的参数创建 <code>Compiler</code> 对象</p>
</li>
<li><p><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等：</p>
<ul>
<li><p>遍历用户定义的 <code>plugins</code> 集合，执行插件的 <code>apply</code> 方法</p>
</li>
<li><p>调用 <code>new WebpackOptionsApply().process</code> 方法，加载各种内置插件</p>
</li>
</ul>
</li>
<li><p><strong>开始编译</strong>：执行 <code>compiler</code> 对象的 <code>run</code> 方法</p>
</li>
<li><p><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilition.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</p>
</li>
</ol>
<h5 id="ii-构建阶段"><a href="#ii-构建阶段" class="headerlink" title="ii. 构建阶段"></a>ii. 构建阶段</h5><ol>
<li>**编译模块(make)**：根据 <code>entry</code> 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理：<ul>
<li>调用 <code>handleModuleCreate</code> ，根据文件类型构建 <code>module</code> 子类</li>
<li>调用 loader-runner 仓库的 <code>runLoaders</code> 转译 <code>module</code> 内容，通常是从各类资源类型转译为 JavaScript 文本</li>
<li>调用 acorn 将 JS 文本解析为 AST</li>
<li>遍历 AST，触发各种钩子<ul>
<li>在 <code>HarmonyExportDependencyParserPlugin</code> 插件监听 <code>exportImportSpecifier</code> 钩子，解读 JS 文本对应的资源依赖</li>
<li>调用 <code>module</code> 对象的 <code>addDependency</code> 将依赖对象加入到 <code>module</code> 依赖列表中</li>
</ul>
</li>
<li>AST 遍历完毕后，调用 <code>module.handleParseResult</code> 处理模块依赖</li>
<li>对于 <code>module</code> 新增的依赖，调用 <code>handleModuleCreate</code> ，控制流回到第一步</li>
<li>所有依赖都解析完毕后，构建阶段结束</li>
</ul>
</li>
<li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的<strong>依赖关系图</strong></li>
</ol>
<h5 id="iii-生成阶段"><a href="#iii-生成阶段" class="headerlink" title="iii. 生成阶段"></a>iii. 生成阶段</h5><ol>
<li>**输出资源(seal)**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会：<ul>
<li>构建本次编译的 <code>ChunkGraph</code> 对象；</li>
<li>遍历 <code>compilation.modules</code> 集合，将 <code>module</code> 按 <code>entry/动态引入</code> 的规则分配给不同的 <code>Chunk</code> 对象；</li>
<li><code>compilation.modules</code> 集合遍历完毕后，得到完整的 <code>chunks</code> 集合对象，调用 <code>createXxxAssets</code> 方法</li>
<li><code>createXxxAssets</code> 遍历 <code>module/chunk</code> ，调用 <code>compilation.emitAssets</code> 方法将 <code>assets</code> 信息记录到 <code>compilation.assets</code> 对象中</li>
</ul>
</li>
<li>**写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统：<ul>
<li>触发 <code>seal</code> 回调，控制流回到 <code>compiler</code> 对象</li>
<li><code>compiler</code> 对象调用<code>outputFileSystem.writeFile</code>输出文件</li>
</ul>
</li>
</ol>
<h5 id="iv-资源形态流转"><a href="#iv-资源形态流转" class="headerlink" title="iv. 资源形态流转"></a>iv. 资源形态流转</h5><p><img src="/./images/23-4-14/webpack-resource.png" alt="webpack-resource"></p>
<p>原理详细可参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483744&amp;idx=1&amp;sn=d7128a76eed20746cd8c5100f0899138&amp;chksm=cf00bc19f877350f17844b283fa0f39daa111864aa69f0be8ce05d3809c51496da43de018a17&amp;scene=178&amp;cur_album_id=1856066636953272321#rd">https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247483744&amp;idx=1&amp;sn=d7128a76eed20746cd8c5100f0899138&amp;chksm=cf00bc19f877350f17844b283fa0f39daa111864aa69f0be8ce05d3809c51496da43de018a17&amp;scene=178&amp;cur_album_id=1856066636953272321#rd</a></p>
<h3 id="3、依赖图-dependency-graph"><a href="#3、依赖图-dependency-graph" class="headerlink" title="3、依赖图(dependency graph)"></a>3、依赖图(dependency graph)</h3><p>Dependency Graph 概念在 webpack 官网是这样解释的：</p>
<blockquote>
<p>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 _依赖关系_。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 <em>依赖</em> 提供给应用程序。</p>
<p>当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从入口开始，webpack 会递归的构建一个 _依赖关系图_，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 <em>bundle</em> —— 通常只有一个 —— 可由浏览器加载。</p>
</blockquote>
<p>就是 webpack 处理应用代码时，会从开发者提供的 entry 开始递归地组建起包含所有模块的 <strong>dependency graph</strong>，之后再将这些 module 打包为 bundles 。</p>
<p>经过上述<a href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">webpack 核心流程</a>可知，Dependency Graph 贯穿 webpack 整个运行周期，从[构建阶段](#ii. 构建阶段)的模块解析，到[生成阶段](#iii. 生成阶段)的 chunk 生成，以及 tree-shaking 功能都高度依赖于 Dependency Graph ，是 webpack 资源构建的一个非常核心的数据结构。</p>
<p>先了解 webpack 几个重要的概念：</p>
<ul>
<li><p><code>Module</code>：资源在 webpack 内部的映射对象，包含了资源的路径、上下文、依赖、内容等信息</p>
</li>
<li><p><code>Dependency</code> ：在模块中引用其它模块，例如 <code>import &quot;a.js&quot;</code> 语句，webpack 会先将引用关系表述为 Dependency 子类并关联 module 对象，等到当前 module 内容都解析完毕之后，启动下次循环开始将 Dependency 对象转换为适当的 Module 子类。</p>
</li>
<li><p><code>Chunk</code> ：用于组织输出结构的对象，webpack 分析完所有模块资源的内容，构建出完整的 Dependency Graph 之后，会根据用户配置及 Dependency Graph 内容构建出一个或多个 chunk 实例，每个 chunk 与最终输出的文件大致上是一一对应的。</p>
</li>
</ul>
<p>下面开始介绍 Dependency Graph 的内在数据结构、依赖关系收集过程及构建 ChunkGraph 过程。</p>
<h5 id="i-数据结构"><a href="#i-数据结构" class="headerlink" title="i. 数据结构"></a>i. 数据结构</h5><p>Webpack 5.0 之后则实现了一套相对复杂的类结构记录模块间依赖关系，如下图所示：</p>
<p><img src="/./images/23-4-14/module-graph.png" alt="module-graph"></p>
<p>可知，将模块依赖相关的逻辑从 Dependence&#x2F;Module 解耦为一套独立的类型结构，主要类型有：</p>
<ul>
<li><p><code>ModuleGraph</code> ：记录 Dependency Graph 信息的容器，一方面保存了构建过程中涉及到的所有 <code>module</code> 、<code>dependency</code> 对象，以及这些对象互相之间的引用；另一方面提供了各种工具方法，方便使用者迅速读取出 <code>module</code> 或 <code>dependency</code> 附加的信息</p>
</li>
<li><p><code>ModuleGraphConnection</code> ：记录模块间引用关系的数据结构，内部通过 <code>originModule</code> 属性记录引用关系中的父模块，通过 <code>module</code> 属性记录子模块。此外还提供了一系列函数工具用于判断对应的引用关系的有效性</p>
</li>
<li><p><code>ModuleGraphModule</code> ：<code>Module</code> 对象在 Dependency Graph 体系下的补充信息，包含模块对象的 <code>incomingConnections</code> —— 指向模块本身的 ModuleGraphConnection 集合，即谁引用了模块自己；<code>outgoingConnections</code> —— 该模块对外的依赖，即该模块引用了其他那些模块。</p>
</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li><p><code>ModuleGraph</code> 对象通过 <code>_dependencyMap</code> 属性记录 <code>Dependency</code> 对象与 <code>ModuleGraphConnection</code> 连接对象之间的映射关系，后续的处理中可以基于这层映射迅速找到 <code>Dependency</code> 实例对应的引用与被引用者</p>
</li>
<li><p><code>ModuleGraph</code> 对象通过 <code>_moduleMap</code> 在 <code>module</code> 基础上附加 <code>ModuleGraphModule</code> 信息，而 <code>ModuleGraphModule</code> 最大的作用就是记录了模块的引用与被引用关系，后续的处理可以基于该属性找到 <code>module</code> 实例的所有依赖与被依赖关系</p>
</li>
</ul>
<h5 id="ii-依赖收集过程"><a href="#ii-依赖收集过程" class="headerlink" title="ii. 依赖收集过程"></a>ii. 依赖收集过程</h5><p><code>ModuleGraph</code>、<code>ModuleGraphConnection</code>、<code>ModuleGraphModule</code> 三者协作，在 webpack [构建过程(make 阶段)](#ii. 构建阶段)中逐步收集模块间的依赖关系，可以参考<a href="#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">webpack 核心流程</a>的流程图，可知，依赖关系收集过程主要发生在两个节点：</p>
<ul>
<li><p><code>addDependency</code> ：webpack 从模块内容中解析出引用关系后，创建适当的 <code>Dependency</code> 子类并调用该方法记录到 <code>module</code> 实例</p>
</li>
<li><p><code>handleModuleCreation</code> ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 <code>Dependency</code> 对应的子模块对象，之后调用 <code>compilation.moduleGraph.setResolvedModule</code> 方法将父子引用信息记录到 <code>moduleGraph</code> 对象上</p>
</li>
</ul>
<p><code>setResolvedModule</code> 方法的逻辑大致为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModuleGraph</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Map&lt;Dependency, ModuleGraphConnection&gt;</span>&#125; */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dependencyMap</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Map&lt;Module, ModuleGraphModule&gt;</span>&#125; */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_moduleMap</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Module</span>&#125; originModule the referencing module</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Dependency</span>&#125; dependency the referencing dependency</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Module</span>&#125; module the referenced module</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">setResolvedModule</span>(<span class="params">originModule, dependency, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">new</span> <span class="title class_">ModuleGraphConnection</span>(</span><br><span class="line">      originModule,</span><br><span class="line">      dependency,</span><br><span class="line">      <span class="variable language_">module</span>,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      dependency.<span class="property">weak</span>,</span><br><span class="line">      dependency.<span class="title function_">getCondition</span>(<span class="variable language_">this</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dependencyMap</span>.<span class="title function_">set</span>(dependency, connection);</span><br><span class="line">    <span class="keyword">const</span> connections = <span class="variable language_">this</span>.<span class="title function_">_getModuleGraphModule</span>(<span class="variable language_">module</span>).<span class="property">incomingConnections</span>;</span><br><span class="line">    connections.<span class="title function_">add</span>(connection);</span><br><span class="line">    <span class="keyword">const</span> mgm = <span class="variable language_">this</span>.<span class="title function_">_getModuleGraphModule</span>(originModule);</span><br><span class="line">    <span class="keyword">if</span> (mgm.<span class="property">outgoingConnections</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      mgm.<span class="property">outgoingConnections</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    mgm.<span class="property">outgoingConnections</span>.<span class="title function_">add</span>(connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例代码主要更改了 <code>_dependencyMap</code> 及 <code>moduleGraphModule</code> 的出入 <code>connections</code> 属性，以此收集当前模块的上下游依赖关系。</p>
<p>可以看个简单例子，对于如下图的依赖关系：</p>
<p><img src="/./images/23-4-14/module-graph-demo.png" alt="module-graph-demo"></p>
<p>Webpack 启动后，在构建阶段递归调用 <code>compilation.handleModuleCreation</code> 函数，逐步补齐 Dependency Graph 结构，最终可能生成如下数据结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ModuleGraph</span>: &#123;</span><br><span class="line">    <span class="attr">_dependencyMap</span>: <span class="title class_">Map</span>(<span class="number">3</span>)&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">EntryDependency</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphConnection</span>&#123;</span><br><span class="line">                <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;,</span><br><span class="line">                <span class="comment">// 入口模块没有引用者，故设置为 null</span></span><br><span class="line">                <span class="attr">originModule</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">HarmonyImportSideEffectDependency</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphConnection</span>&#123;</span><br><span class="line">                <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;,</span><br><span class="line">                <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">HarmonyImportSideEffectDependency</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphConnection</span>&#123;</span><br><span class="line">                <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;,</span><br><span class="line">                <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">_moduleMap</span>: <span class="title class_">Map</span>(<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphModule</span>&#123;</span><br><span class="line">            <span class="attr">incomingConnections</span>: <span class="title class_">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                <span class="comment">// entry 模块，对应 originModule 为null</span></span><br><span class="line">                <span class="title class_">ModuleGraphConnection</span>&#123; <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;, <span class="attr">originModule</span>:<span class="literal">null</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">outgoingConnections</span>: <span class="title class_">Set</span>(<span class="number">2</span>) [</span><br><span class="line">                <span class="comment">// 从 index 指向 a 模块</span></span><br><span class="line">                <span class="title class_">ModuleGraphConnection</span>&#123; <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;, <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;,</span><br><span class="line">                <span class="comment">// 从 index 指向 b 模块</span></span><br><span class="line">                <span class="title class_">ModuleGraphConnection</span>&#123; <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;, <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphModule</span>&#123;</span><br><span class="line">            <span class="attr">incomingConnections</span>: <span class="title class_">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                <span class="title class_">ModuleGraphConnection</span>&#123; <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;, <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// a 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span></span><br><span class="line">            <span class="attr">outgoingConnections</span>: <span class="literal">undefined</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125; =&gt; <span class="title class_">ModuleGraphModule</span>&#123;</span><br><span class="line">            <span class="attr">incomingConnections</span>: <span class="title class_">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                <span class="title class_">ModuleGraphConnection</span>&#123; <span class="attr">module</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;, <span class="attr">originModule</span>: <span class="title class_">NormalModule</span>&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// b 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span></span><br><span class="line">            <span class="attr">outgoingConnections</span>: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的 Dependency Graph 可以看出，本质上 <code>ModuleGraph._moduleMap</code> 已经形成了一个有向无环图结构，其中字典 <code>_moduleMap</code> 的 key 为图的节点，对应 value <code>ModuleGraphModule</code> 结构中的 <code>outgoingConnections</code> 属性为图的边，则上例中从起点 <code>index.js</code> 出发沿 <code>outgoingConnections</code> 向前可遍历出图的所有顶点。</p>
<h5 id="iii-构建-ChunkGraph"><a href="#iii-构建-ChunkGraph" class="headerlink" title="iii. 构建 ChunkGraph"></a>iii. 构建 ChunkGraph</h5><p>Webpack 主体流程中，make 构建阶段结束之后会进入 <code>seal</code> 阶段，开始梳理以何种方式组织输出内容。在<code>seal</code> 阶段与 Dependency Graph 类似也引入了一套全新的基于 <code>ChunkGraph</code> 的图结构实现资源生成算法。</p>
<p>在 compilation.seal 函数中，首先根据默认规则 —— 每个 entry 对应组织为一个 chunk ，之后调用 <code>webpack/lib/buildChunkGraph.js</code> 文件定义的 <code>buildChunkGraph</code> 方法，遍历 <code>make</code> 阶段生成的 <code>moduleGraph</code> 对象从而将 module 依赖关系转化为 <code>chunkGraph</code> 对象。</p>
<h3 id="4、插件架构"><a href="#4、插件架构" class="headerlink" title="4、插件架构"></a>4、插件架构</h3><p>webpack 的插件体系是一种基于 Tapable 库实现的强耦合架构，它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程。</p>
<h5 id="i-什么是插件"><a href="#i-什么是插件" class="headerlink" title="i. 什么是插件"></a>i. 什么是插件</h5><p>插件通常是一个带有 apply 函数的类，Webpack 会在启动后按照注册的顺序逐次调用插件对象的 apply 函数，同时传入编译器对象 compiler ，插件开发者可以以此为起点触达到 webpack 内部定义的任意钩子，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomePlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&quot;SomePlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>thisCompilation</code> 为 tapable 仓库提供的钩子对象；<code>tap</code> 为订阅函数，用于注册回调。</p>
<h5 id="ii-Tapable-库"><a href="#ii-Tapable-库" class="headerlink" title="ii. Tapable 库"></a>ii. Tapable 库</h5><p>Tapable 是 Webpack 插件架构的核心支架，本质上就是围绕着 订阅&#x2F;发布 模式叠加各种特化逻辑，适配 webpack 体系下复杂的事件源-处理器之间交互需求，比如说有些场景需要支持将前一个处理器的结果传入下一个回调处理器；有些场景需要支持异步并行调用这些回调处理器。</p>
<p>Tapable 使用时通常需要经历如下步骤：</p>
<ul>
<li>创建钩子实例</li>
<li>调用订阅接口注册回调，包括：<code>tap、tapAsync、tapPromise</code></li>
<li>调用发布接口触发回调，包括：<code>call、callAsync、promise</code></li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建钩子实例</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> <span class="title class_">SyncHook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用订阅接口注册回调</span></span><br><span class="line">sleep.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用发布接口触发回调</span></span><br><span class="line">sleep.<span class="title function_">call</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br></pre></td></tr></table></figure>

<p>Tabable 提供的钩子类型有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>SyncHook</td>
<td>同步钩子</td>
</tr>
<tr>
<td>SyncBailHook</td>
<td>同步熔断钩子</td>
</tr>
<tr>
<td>SyncWaterfallHook</td>
<td>同步瀑布流钩子</td>
</tr>
<tr>
<td>SyncLoopHook</td>
<td>同步循环钩子</td>
</tr>
<tr>
<td>AsyncParallelHook</td>
<td>异步并行钩子</td>
</tr>
<tr>
<td>AsyncParallelBailHook</td>
<td>异步并行熔断钩子</td>
</tr>
<tr>
<td>AsyncSeriesHook</td>
<td>异步串行钩子</td>
</tr>
<tr>
<td>AsyncSeriesBailHook</td>
<td>异步串行熔断钩子</td>
</tr>
<tr>
<td>AsyncSeriesLoopHook</td>
<td>异步串行循环钩子</td>
</tr>
<tr>
<td>AsyncSeriesWaterfallHook</td>
<td>异步串行瀑布流钩子</td>
</tr>
</tbody></table>
<ol>
<li><p>SyncHook</p>
<p><code>SyncHook</code> 触发后会按照注册的顺序逐个调用回调，且不关心这些回调的返回值。</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">syncCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2, fn3];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = callbacks[i];</span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Somebody</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">sleep</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 触发回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">call</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Somebody</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sleep</span>();</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// callback B</span></span><br><span class="line"><span class="comment">// callback C</span></span><br></pre></td></tr></table></figure>

<p><code>SyncHook</code> 触发回调也可以选择异步风格的 <code>callAsync</code> ，与 <code>call</code> 区别是 <code>callAsync</code> 需要传入 <code>callback</code> 函数，用于处理回调队列可能抛出的异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call 风格</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">call</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 错误处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// callAsync 风格</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">callAsync</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用<code>callAsync</code>函数来触发回调的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Somebody</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">sleep</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//   触发回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">callAsync</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`interrupt with &quot;<span class="subst">$&#123;err.message&#125;</span>&quot;`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Somebody</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;我就是要报错&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第一个回调出错后，后续回调不会执行</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sleep</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// interrupt with &quot;我就是要报错&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncBailHook</p>
<p><code>bail</code> 类型钩子的特点是在回调队列中，若任一回调返回了非 <code>undefined</code> 的值，则中断后续处理，直接返回该值。</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bailCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2, fn3];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> callbacks) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = callbacks[i];</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title function_">cb</span>(lastResult);</span><br><span class="line">    <span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 熔断</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncBailHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Somebody</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">sleep</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">call</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Somebody</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">  <span class="comment">// 熔断点</span></span><br><span class="line">  <span class="comment">// 返回非 undefined 的任意值都会中断回调队列</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;返回值：jason&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">sleep</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// 返回值：jason</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncWaterfallHook</p>
<p><code>waterfall</code> 钩子的执行逻辑跟 lodash 的 <code>flow</code> 函数有点像，大致上就是会将前一个函数的返回值作为参数传入下一个函数。</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">waterfallCall</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2, fn3];</span><br><span class="line">  <span class="keyword">let</span> lastResult = arg;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> callbacks) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = callbacks[i];</span><br><span class="line">    <span class="comment">// 上次执行结果作为参数传入下一个函数</span></span><br><span class="line">    lastResult = <span class="title function_">cb</span>(lastResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncWaterfallHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Somebody</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">sleep</span>: <span class="keyword">new</span> <span class="title class_">SyncWaterfallHook</span>([<span class="string">&quot;msg&quot;</span>]),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Somebody</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`call 调用传入： <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;arg&#125;</span> jason`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`A 回调返回： <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;最终结果：&quot;</span> + person.<span class="title function_">sleep</span>());</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// call 调用传入： hello</span></span><br><span class="line"><span class="comment">// A 回调返回： hello jason</span></span><br><span class="line"><span class="comment">// 最终结果：hello jason</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncLoopHook</p>
<p><code>loop</code> 型钩子的特点是循环执行直到所有回调都返回 <code>undefined</code> ，不过这里循环的维度是单个回调函数，例如有回调队列 <code>[fn1, fn2, fn3]</code> ，<code>loop</code> 钩子先执行 <code>fn1</code> ，如果此时 <code>fn1</code> 返回了非 <code>undefined</code> 值，则继续执行 <code>fn1</code> 直到返回 <code>undefined</code> 后才向前推进执行 <code>fn2</code> 。</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loopCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2, fn3];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> callbacks) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = callbacks[i];</span><br><span class="line">    <span class="comment">// 重复执行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">cb</span>() !== <span class="literal">undefined</span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncLoopHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Somebody</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">sleep</span>: <span class="keyword">new</span> <span class="title class_">SyncLoopHook</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">call</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Somebody</span>();</span><br><span class="line"><span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  ++times;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第 <span class="subst">$&#123;times&#125;</span> 次执行回调A`</span>);</span><br><span class="line">  <span class="keyword">if</span> (times &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> times;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="property">hooks</span>.<span class="property">sleep</span>.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`执行回调B`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sleep</span>();</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// 第 1 次执行回调A</span></span><br><span class="line"><span class="comment">// 第 2 次执行回调A</span></span><br><span class="line"><span class="comment">// 第 3 次执行回调A</span></span><br><span class="line"><span class="comment">// 第 4 次执行回调A</span></span><br><span class="line"><span class="comment">// 执行回调B</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncSeriesHook</p>
<p><code>Async</code> 开头的异步钩子，支持在回调函数中执行异步操作：</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncSeriesCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2, fn3];</span><br><span class="line">  <span class="comment">//   执行回调 1</span></span><br><span class="line">  <span class="title function_">fn1</span>(<span class="function">(<span class="params">err1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err1) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(err1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//   执行回调 2</span></span><br><span class="line">      <span class="title function_">fn2</span>(<span class="function">(<span class="params">err2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err2) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(err2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//   执行回调 3</span></span><br><span class="line">          <span class="title function_">fn3</span>(<span class="function">(<span class="params">err3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err3) &#123;</span><br><span class="line">              <span class="title function_">callback</span>(err2);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">AsyncSeriesHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">hook.<span class="title function_">tapAsync</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A 异步操作结束&quot;</span>);</span><br><span class="line">    <span class="comment">// 回调结束时，调用 cb 通知 tapable 当前回调已结束</span></span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">tapAsync</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">callAsync</span>();</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// callback A 异步操作结束</span></span><br><span class="line"><span class="comment">// callback B</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>callback</code> 风格外，也可以使用 <code>promise</code> 风格调用 <code>tap/call</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">AsyncSeriesHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">hook.<span class="title function_">tapPromise</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A 异步操作结束&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">tapPromise</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">promise</span>();</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// callback A 异步操作结束</span></span><br><span class="line"><span class="comment">// callback B</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncParallelHook</p>
<p>与 <code>AsyncSeriesHook</code> 类似，<code>AsyncParallelHook</code> 也支持异步风格的回调，不过 <code>AsyncParallelHook</code> 是以并行方式，同时执行回调队列里面的所有回调。</p>
<p>实现原理如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncParallelCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [fn1, fn2];</span><br><span class="line">  <span class="comment">// 内部维护了一个计数器</span></span><br><span class="line">  <span class="keyword">var</span> _counter = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _done = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">_callback</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (_counter &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 按序执行回调</span></span><br><span class="line">  <span class="keyword">var</span> _fn0 = callbacks[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">_fn0</span>(<span class="keyword">function</span> (<span class="params">_err0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_err0) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 出错时，忽略后续回调，直接退出</span></span><br><span class="line">        <span class="title function_">_callback</span>(_err0);</span><br><span class="line">        _counter = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (--_counter === <span class="number">0</span>) <span class="title function_">_done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (_counter &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 不需要等待前面回调结束，直接开始执行下一个回调</span></span><br><span class="line">  <span class="keyword">var</span> _fn1 = callbacks[<span class="number">1</span>];</span><br><span class="line">  <span class="title function_">_fn1</span>(<span class="keyword">function</span> (<span class="params">_err1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_err1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">_callback</span>(_err1);</span><br><span class="line">        _counter = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (--_counter === <span class="number">0</span>) <span class="title function_">_done</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">AsyncParallelHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">AsyncParallelHook</span>([<span class="string">&quot;hello&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调</span></span><br><span class="line">hook.<span class="title function_">tapPromise</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A 异步操作结束&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">tapPromise</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hook.<span class="title function_">promise</span>();</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br><span class="line"><span class="comment">// callback B</span></span><br><span class="line"><span class="comment">// callback A 异步操作结束</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其它钩子</p>
<ul>
<li><code>AsyncParallelBailHook</code> ：异步 + 并行 + 熔断，启动后同时执行所有回调，但任意回调有返回值时，忽略剩余未执行完的回调，直接返回该结果</li>
<li><code>AsyncSeriesBailHook</code> ：异步 + 串行 + 熔断，启动后按序逐个执行回调，过程中若有任意回调返回非 undefined 值，则停止后续调用，直接返回该结果</li>
<li><code>AsyncSeriesLoopHook</code>： 异步 + 串行 + 循环，启动后按序逐个执行回调，若有任意回调返回非 <code>undefined</code> 值，则重复执行该回调直到返回 <code>undefined</code> 后，才继续执行下一个回调</li>
</ul>
</li>
<li><p>动态编译</p>
<p>Tapable 所谓的同步、异步、bail、waterfall、loop 等回调规则都是基于动态编译能力实现的。</p>
<p>当用户执行钩子发布函数 <code>call/callAsync/promise</code> 时，tapable 会根据钩子类型、参数、回调队列等信息动态生成执行函数，例如对于下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> <span class="title class_">SyncHook</span>();</span><br><span class="line"></span><br><span class="line">sleep.<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">sleep.<span class="title function_">call</span>();</span><br></pre></td></tr></table></figure>

<p>调用 <code>sleep.call</code> 时，tapable 内部处理大致流程如下图：</p>
<p><img src="/./images/23-4-14/tapable%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91.png" alt="tapable动态编译"></p>
<p><code>SyncHook</code> (其他钩子类似) 调用 <code>call</code> 后，<code>Hook</code> 基类收集上下文信息并调用 <code>createCall</code> 及子类传入的 <code>compiler</code> 函数；<code>compiler</code> 调用 <code>HookCodeFactory</code> 进而使用 <code>new Function</code> 方法动态拼接出回调执行函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> _context;</span><br><span class="line">  <span class="keyword">var</span> _x = <span class="variable language_">this</span>.<span class="property">_x</span>;</span><br><span class="line">  <span class="keyword">var</span> _fn0 = _x[<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">_fn0</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>高级特性：Intercept</p>
<p>除了通常的 <code>tap/call</code> 之外，tapable 还提供了简易的中间件机制 —— <code>intercept</code> 接口，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> <span class="title class_">SyncHook</span>();</span><br><span class="line"></span><br><span class="line">sleep.<span class="title function_">intercept</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before call&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before loop&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">tap</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before each callback&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">register</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;every time call tap&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>intercept</code> 支持注册如下类型的中间件：</p>
<table>
<thead>
<tr>
<th></th>
<th>签名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>call</td>
<td>(…args) &#x3D;&gt; void</td>
<td>调用 call&#x2F;callAsync&#x2F;promise 时触发</td>
</tr>
<tr>
<td>tap</td>
<td>(tap: Tap) &#x3D;&gt; void</td>
<td>调用 call 类函数后，每次调用回调之前触发</td>
</tr>
<tr>
<td>loop</td>
<td>(…args) &#x3D;&gt; void</td>
<td>仅 loop 型的钩子有效，在循环开始之前触发</td>
</tr>
<tr>
<td>register</td>
<td>(tap: Tap) &#x3D;&gt; Tap | undefined</td>
<td>调用 tap&#x2F;tapAsync&#x2F;tapPromise 时触发</td>
</tr>
</tbody></table>
<p>其中 <code>register</code> 在每次调用 tap 时被调用；其他三种中间件的触发时机大致如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _context;</span><br><span class="line"><span class="keyword">const</span> callbacks = [fn1, fn2];</span><br><span class="line"><span class="keyword">var</span> _interceptors = <span class="variable language_">this</span>.<span class="property">interceptors</span>;</span><br><span class="line"><span class="comment">// 调用 call 函数，立即触发</span></span><br><span class="line">_interceptors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">intercept</span>) =&gt;</span> intercept.<span class="title function_">call</span>(_context));</span><br><span class="line"><span class="keyword">var</span> _loop;</span><br><span class="line"><span class="keyword">var</span> cursor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  _loop = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 每次循环开始时触发 `loop`</span></span><br><span class="line">  _interceptors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">intercept</span>) =&gt;</span> intercept.<span class="title function_">loop</span>(_context));</span><br><span class="line">  <span class="comment">// 触发 `tap`</span></span><br><span class="line">  <span class="keyword">var</span> _fn0 = callbacks[<span class="number">0</span>];</span><br><span class="line">  _interceptors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">intercept</span>) =&gt;</span> intercept.<span class="title function_">tap</span>(_context, _fn0));</span><br><span class="line">  <span class="keyword">var</span> _result0 = <span class="title function_">_fn0</span>();</span><br><span class="line">  <span class="keyword">if</span> (_result0 !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    _loop = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _fn1 = callbacks[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 再次触发 `tap`</span></span><br><span class="line">    _interceptors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">intercept</span>) =&gt;</span> intercept.<span class="title function_">tap</span>(_context, _fn1));</span><br><span class="line">    <span class="keyword">var</span> _result1 = <span class="title function_">_fn1</span>();</span><br><span class="line">    <span class="keyword">if</span> (_result1 !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      _loop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (_loop);</span><br></pre></td></tr></table></figure>

<p><code>intercept</code> 特性在 webpack 内主要被用作进度提示，如 <code>webpack/lib/ProgressPlugin</code> 插件中，分别对 <code>compiler.hooks.emit</code> 、<code>compiler.hooks.afterEmit</code> 钩子应用了记录进度的中间件函数。</p>
</li>
<li><p>高级特性：HookMap</p>
<p>Tapable 还有一个特性值得注意的特性 —— <code>HookMap</code> 。<code>HookMap</code> 提供了一种集合操作能力，能够降低创建与使用的复杂度，用法比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span>, <span class="title class_">HookMap</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> <span class="title class_">HookMap</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">SyncHook</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 for 函数过滤集合中的特定钩子</span></span><br><span class="line">sleep.<span class="title function_">for</span>(<span class="string">&quot;statement&quot;</span>).<span class="title function_">tap</span>(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback for statement&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 statement 类型的钩子</span></span><br><span class="line">sleep.<span class="title function_">get</span>(<span class="string">&quot;statement&quot;</span>).<span class="title function_">call</span>();</span><br></pre></td></tr></table></figure>

<p>在 webpack 中，HookMap 集中在 <code>webpack/lib/parser.js</code> 文件中，<code>parser</code> 文件主要完成将资源内容解析为 AST 集合，解析完成后遍历 AST 并以钩子方式对外通知遍历到的内容。例如遇到表达式的时候触发 <code>Parser.hooks.expression</code> 钩子，问题是 AST 结构和内容都很复杂，如果所有情景都以独立的钩子实现，那代码量工作量会急剧膨胀。这种场景就很适合用 <code>HookMap</code> 解决。</p>
</li>
</ol>
<h5 id="iii-Webpack-插件架构"><a href="#iii-Webpack-插件架构" class="headerlink" title="iii. Webpack 插件架构"></a>iii. Webpack 插件架构</h5><p>综上，webpack 为开发者提供了基于 tapable 钩子的插件方案：</p>
<ol>
<li>编译过程的特定节点以钩子形式，通知插件此刻正在发生什么事情；</li>
<li>通过 tapable 提供的回调机制，以参数方式传递上下文信息；</li>
<li>在上下文参数对象中附带了很多存在 side effect 的交互接口，插件可以通过这些接口改变</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="comment">// 在构造函数中，先初始化钩子对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">thisCompilation</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;compilation&quot;</span>, <span class="string">&quot;params&quot;</span>]),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">compile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 特定时机触发特定钩子</span></span><br><span class="line">    <span class="keyword">const</span> compilation = <span class="keyword">new</span> <span class="title class_">Compilation</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">call</span>(compilation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Compiler</code> 类型内部定义了 <code>thisCompilation</code> 钩子，并在 <code>compilation</code> 创建完毕后发布事件消息，插件开发者就可以基于这个钩子获取到最新创建出的 <code>compilation</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomePlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&quot;SomePlugin&quot;</span>, <span class="function">(<span class="params">compilation, params</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 上下文信息： compilation、params</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>钩子回调传递的 <code>compilation/params</code> 参数就是 webpack 希望传递给插件的上下文信息，也是插件能拿到的输入。不同钩子会传递不同的上下文对象，这一点在钩子被创建的时候就定下来了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">SyncBailHook&lt;Compilation&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">shouldEmit</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;Stats&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">done</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;stats&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">additionalPass</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;Compiler&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">beforeRun</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compiler&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;Compiler&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">run</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compiler&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;Compilation&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">emit</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;string, Buffer&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">assetEmitted</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;file&quot;</span>, <span class="string">&quot;content&quot;</span>]),</span><br><span class="line">      <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">AsyncSeriesHook&lt;Compilation&gt;</span>&#125; */</span></span><br><span class="line">      <span class="attr">afterEmit</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的参数对象有 <code>compilation/module/stats/compiler/file/chunks</code> 等，在钩子回调中可以通过改变这些对象的状态，影响 webpack 的编译逻辑。</p>
<p>所以，如果想顺利编写出符合需求的插件，还需要了解学习更多 webpack 内置对象的功能、特点、接口等内容。</p>
<h5 id="iv-了解-Webpack-内置对象的钩子"><a href="#iv-了解-Webpack-内置对象的钩子" class="headerlink" title="iv. 了解 Webpack 内置对象的钩子"></a>iv. 了解 Webpack 内置对象的钩子</h5><p>可以从钩子的触发时机、传递参数、示例代码来进行了解，从而知道如何去编写符合需求的插件。</p>
<ol>
<li><p>触发时机</p>
<p><code>compiler</code> 对象逐次触发如下钩子：</p>
<p><img src="/./images/23-4-14/compiler-hook.png" alt="compiler-hook"></p>
<p><code>compilation</code> 对象逐次触发如下钩子：</p>
<p><img src="/./images/23-4-14/compilation-hook.png" alt="compilation-hook"></p>
</li>
<li><p>传递参数</p>
<p>传递参数与具体的钩子强相关，官网对这方面没有做出进一步解释，我的做法是直接在源码里面搜索调用语句，例如对于 <code>compilation.hooks.optimizeTree</code> ，可以在 webpack 源码中搜索 <code>hooks.optimizeTree.call</code> 关键字，就可以找到调用代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/compilation.js#2297</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">optimizeTree</span>.<span class="title function_">callAsync</span>(<span class="variable language_">this</span>.<span class="property">chunks</span>, <span class="variable language_">this</span>.<span class="property">modules</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>结合代码所在的上下文，可以判断出此时传递的是经过优化的 <code>chunks</code> 及 <code>modules</code> 集合。</p>
</li>
<li><p>示例代码</p>
<p>可以带着目的去查询其他插件中如何使用这些钩子。例如，在 <code>compilation.seal</code> 函数内部有 <code>optimizeModules</code> 和 <code>afterOptimizeModules</code> 这一对看起来很对偶的钩子，<code>optimizeModules</code> 从字面上可以理解为用于优化已经编译出的 <code>modules</code> ，那 <code>afterOptimizeModules</code> 呢？</p>
<p>从 webpack 源码中唯一搜索到的用途是 <code>ProgressPlugin</code> ，大体上逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">compilation.<span class="property">hooks</span>.<span class="property">afterOptimizeModules</span>.<span class="title function_">intercept</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ProgressPlugin&quot;</span>,</span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">done</span>(<span class="params"></span>) &#123;</span><br><span class="line">    progressReporters.<span class="title function_">set</span>(compiler, <span class="literal">undefined</span>);</span><br><span class="line">    <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">result</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">tap</span>(<span class="params">tap</span>) &#123;</span><br><span class="line">    <span class="comment">// p is percentage from 0 to 1</span></span><br><span class="line">    <span class="comment">// args is any number of messages in a hierarchical matter</span></span><br><span class="line">    progressReporters.<span class="title function_">set</span>(compilation.<span class="property">compiler</span>, <span class="function">(<span class="params">p, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title, tap.<span class="property">name</span>, ...args);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">handler</span>(percentage, <span class="string">&quot;sealing&quot;</span>, title, tap.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>基本上可以猜测出，<code>afterOptimizeModules</code> 的设计初衷就是用于通知优化行为的结束。</p>
<p>webpack 插件的<code>apply</code> 虽然是一个函数，但是从设计上就只有输入，webpack 不 care 输出，所以在插件中只能通过调用类型实体的各种方法来或者更改实体的配置信息，变更编译行为。例如：</p>
<ul>
<li><p>compilation.addModule ：添加模块，可以在原有的 module 构建规则之外，添加自定义模块</p>
</li>
<li><p>compilation.emitAsset：直译是“提交资产”，功能可以理解将内容写入到特定路径</p>
</li>
<li><p>compilation.addEntry：添加入口，功能上与直接定义 <code>entry</code> 配置相同</p>
</li>
<li><p>等等…</p>
</li>
</ul>
</li>
</ol>
<h3 id="5、编写-loader"><a href="#5、编写-loader" class="headerlink" title="5、编写 loader"></a>5、编写 loader</h3><h5 id="i-什么是-loader"><a href="#i-什么是-loader" class="headerlink" title="i. 什么是 loader"></a>i. 什么是 loader</h5><p>Webpack Loader 最核心的功能是实现内容转换器 —— 将各式各样的资源转化为标准 JavaScript 内容格式，如：</p>
<ul>
<li><code>css-loader</code> 将 css 转换为 <code>__WEBPACK_DEFAULT_EXPORT__ = &quot;.a&#123; xxx &#125;&quot;</code> 格式</li>
<li><code>html-loader</code> 将 html 转换为 <code>__WEBPACK_DEFAULT_EXPORT__ = &quot;&lt;!DOCTYPE xxx&quot;</code> 格式</li>
<li><code>vue-loader</code> 更复杂一些，会将 <code>.vue</code> 文件转化为多个 JavaScript 函数，分别对应 template、js、css、custom block</li>
</ul>
<p>做这种内容转换，本质上是因为 Webpack 只认识符合 JavaScript 规范的文本(Webpack 5 之后增加了其它 parser)：在构建(make)阶段，解析模块内容时会调用 <code>acorn</code> 将文本转换为 AST 对象，进而分析代码结构，分析模块依赖；这一套逻辑对图片、json、Vue SFC 等场景就不 work 了，就需要 Loader 介入将资源转化成 Webpack 可以理解的内容形态。</p>
<h5 id="ii-了解-loader"><a href="#ii-了解-loader" class="headerlink" title="ii. 了解 loader"></a>ii. 了解 loader</h5><ol>
<li><p>结构</p>
<p>Loader 通常是一个函数，结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source, sourceMap?, data?</span>) &#123;</span><br><span class="line">  <span class="comment">// source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Loader 函数接收三个参数，分别为：</p>
<ul>
<li><code>source</code>：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</li>
<li><code>sourceMap</code>: 可选参数，代码的 sourcemap 结构</li>
<li><code>data</code>: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml&#x2F;posthtml-loader 就会通过这个参数传递参数的 AST 对象</li>
</ul>
<p>其中 <code>source</code> 是最重要的参数，大多数 Loader 要做的事情就是将 <code>source</code> 转译为另一种形式的 <code>output</code>。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">rawLoader</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(source)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\u2028/g</span>, <span class="string">&quot;\\u2028&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\u2029/g</span>, <span class="string">&quot;\\u2029&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.<span class="property">esModule</span> !== <span class="string">&quot;undefined&quot;</span> ? options.<span class="property">esModule</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;esModule ? <span class="string">&quot;export default&quot;</span> : <span class="string">&quot;module.exports =&quot;</span>&#125;</span> <span class="subst">$&#123;json&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是将文本内容包裹成 JavaScript 模块，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source</span></span><br><span class="line">I am <span class="title class_">Tecvan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&quot;I am Tecvan&quot;</span></span><br></pre></td></tr></table></figure>

<p>经过模块化包装之后，这段文本内容转身变成 Webpack 可以处理的资源模块，其它 module 也就能引用、使用它了。</p>
</li>
<li><p>返回多个结果</p>
<p>除了通过 <code>return</code> 语句返回处理结果，除此之外 Loader 还可以以 <code>callback</code> 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content, map</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  linter.<span class="title function_">printOutput</span>(linter.<span class="title function_">lint</span>(content));</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>this.callback(null, content, map)</code> 语句同时返回转译后的内容与 sourcemap 内容。<code>callback</code> 的完整签名如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">callback</span>(</span><br><span class="line">    <span class="comment">// 异常信息，Loader 正常运行时传递 null 值即可</span></span><br><span class="line">    <span class="attr">err</span>: <span class="title class_">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 转译结果</span></span><br><span class="line">    <span class="attr">content</span>: string | <span class="title class_">Buffer</span>,</span><br><span class="line">    <span class="comment">// 源码的 sourcemap 信息</span></span><br><span class="line">    sourceMap?: <span class="title class_">SourceMap</span>,</span><br><span class="line">    <span class="comment">// 任意需要在 Loader 间传递的值。经常用来传递 ast 对象，避免重复解析</span></span><br><span class="line">    data?: any</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步处理</p>
<p>涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> less <span class="keyword">from</span> <span class="string">&quot;less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">lessLoader</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 获取异步回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 调用less 将模块内容转译为 css</span></span><br><span class="line">    result = <span class="keyword">await</span> (options.<span class="property">implementation</span> || less).<span class="title function_">render</span>(</span><br><span class="line">      data,</span><br><span class="line">      lessOptions</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 转译结束，返回结果</span></span><br><span class="line">  <span class="title function_">callback</span>(<span class="literal">null</span>, css, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lessLoader;</span><br></pre></td></tr></table></figure>

<p><code>this.async</code> 返回的异步回调函数签名与上面第 3 小节介绍的 <code>this.callback</code> 相同。</p>
</li>
<li><p>缓存</p>
<p>Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在单线程的 Node 场景下可能导致性能问题。</p>
<p>默认情况下 Webpack 会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 <code>this.cachable</code> 显式声明不作缓存，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">cacheable</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上下文与 side effect</p>
<p>除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。</p>
<p>上下文信息可通过 <code>this</code> 获取，<code>this</code> 对象由 <code>NormolModule.createLoaderContext</code> 函数在调用 Loader 前创建，常用的接口包括：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderContext = &#123;</span><br><span class="line">  <span class="comment">// 获取当前 Loader 的配置信息</span></span><br><span class="line">  <span class="attr">getOptions</span>: <span class="function">(<span class="params">schema</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加警告</span></span><br><span class="line">  <span class="attr">emitWarning</span>: <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加错误信息，注意这不会中断 Webpack 运行</span></span><br><span class="line">  <span class="attr">emitError</span>: <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 解析资源文件的具体路径</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">context, request, callback</span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 直接提交文件，提交的文件不会经过后续的chunk、module处理，直接输出到 fs</span></span><br><span class="line">  <span class="attr">emitFile</span>: <span class="function">(<span class="params">name, content, sourceMap, assetInfo</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加额外的依赖文件</span></span><br><span class="line">  <span class="comment">// watch 模式下，依赖文件发生变化时会触发资源重新编译</span></span><br><span class="line">  <span class="title function_">addDependency</span>(<span class="params">dep</span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = <span class="keyword">await</span> (options.<span class="property">implementation</span> || less).<span class="title function_">render</span>(data, lessOptions);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line"></span><br><span class="line">imports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">addDependency</span>(path.<span class="title function_">normalize</span>(item));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代码中首先调用 <code>less</code> 编译文件内容，之后遍历所有 <code>import</code> 语句，也就是上例 <code>result.imports</code> 数组，一一调用 <code>this.addDependency</code> 函数将 import 到的其它资源都注册为依赖，之后这些其它资源文件发生变化时都会触发重新编译。</p>
</li>
<li><p>loader 链式调用</p>
<p>使用上，可以为某种资源文件配置多个 Loader，Loader 之间按照配置的顺序从前到后(pitch)，再从后到前依次执行，从而形成一套内容转译工作流。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对 <code>.less</code> 后缀的文件设定了：less、css、style 三个 loader 协作处理资源文件，按照定义的顺序，Webpack 解析 less 文件内容后先传入 less-loader；less-loader 返回的结果再传入 css-loader 处理；css-loader 的结果再传入 style-loader；最终以 style-loader 的处理结果为准。</p>
<p>三个 Loader 分别完成内容转化工作的一部分，形成从右到左的调用链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。</p>
</li>
<li><p>loader pitch</p>
<p>Webpack 允许在这个函数上挂载名为 <code>pitch</code> 的函数，运行时 pitch 会比 Loader 本身更早执行，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loader = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;后执行&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">loader.<span class="property">pitch</span> = <span class="keyword">function</span> (<span class="params">requestString</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;先执行&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = loader;</span><br></pre></td></tr></table></figure>

<p>pitch 函数的完整签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * remainingRequest: 当前 loader 之后的资源请求字符串</span></span><br><span class="line"><span class="comment"> *	previousRequest: 在执行当前 loader 之前经历过的 loader 列表</span></span><br><span class="line"><span class="comment"> * data: 与 Loader 函数的 data 相同，用于传递需要在 Loader 传播的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pitch</span>(<span class="params"></span></span><br><span class="line"><span class="params">  remainingRequest: string,</span></span><br><span class="line"><span class="params">  previousRequest: string,</span></span><br><span class="line"><span class="params">  data = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>css-loader.pitch</code> 中拿到的参数依次为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css-loader 之后的 loader 列表及资源路径</span></span><br><span class="line">remainingRequest = less-loader!./xxx.<span class="property">less</span></span><br><span class="line"><span class="comment">// css-loader 之前的 loader 列表</span></span><br><span class="line">previousRequest = style-loader</span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">data = &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调度逻辑</p>
<p>实现上，Loader 链条执行过程分三个阶段：pitch、解析资源、执行，如下图所示：</p>
<p><img src="/./images/23-4-14/loader-pitch.png" alt="loader-pitch"></p>
<p><code>pitch</code> 阶段按配置顺序从左到右逐个执行 <code>loader.pitch</code> 函数(如果有的话)，开发者可以在 <code>pitch</code> 返回任意值中断后续的链路的执行：</p>
<p><img src="/./images/23-4-14/loader-pitch-interapt.png" alt="loader-pitch-interapt"></p>
</li>
</ol>
<h5 id="iii-开发-loader-技巧"><a href="#iii-开发-loader-技巧" class="headerlink" title="iii. 开发 loader 技巧"></a>iii. 开发 loader 技巧</h5><ol>
<li><p>开发工具</p>
<p>Webpack 为 Loader 开发者提供了两个实用工具，在诸多开源 Loader 中出现频率极高：</p>
<ul>
<li>webpack&#x2F;loader-utils：提供了一系列诸如读取配置、requestString 序列化与反序列化、计算 hash 值之类的工具函数</li>
<li>webpack&#x2F;schema-utils：参数校验工具</li>
</ul>
<p>获取并校验配置的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css-loader/src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getOptions &#125; <span class="keyword">from</span> <span class="string">&quot;loader-utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; validate &#125; <span class="keyword">from</span> <span class="string">&quot;schema-utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> schema <span class="keyword">from</span> <span class="string">&quot;./options.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rawOptions = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(schema, rawOptions, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;CSS Loader&quot;</span>,</span><br><span class="line">    <span class="attr">baseDataPath</span>: <span class="string">&quot;options&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>schema-utils</code> 做校验时需要提前声明配置模板，通常会处理成一个额外的 json 文件，例如上例中的 <code>&quot;./options.json&quot;</code>。</p>
<p>拼接输出文件名的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getOptions, interpolateName &#125; <span class="keyword">from</span> <span class="string">&quot;loader-utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = options.<span class="property">context</span> || <span class="variable language_">this</span>.<span class="property">rootContext</span>;</span><br><span class="line">  <span class="keyword">const</span> name = options.<span class="property">name</span> || <span class="string">&quot;[contenthash].[ext]&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接最终输出的名称</span></span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">interpolateName</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">    context,</span><br><span class="line">    content,</span><br><span class="line">    <span class="attr">regExp</span>: options.<span class="property">regExp</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> outputPath = url;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> publicPath = <span class="string">`__webpack_public_path__ + <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(outputPath)&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">emitFile</span> === <span class="string">&quot;undefined&quot;</span> || options.<span class="property">emitFile</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交、写出文件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emitFile</span>(outputPath, content, <span class="literal">null</span>, assetInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.<span class="property">esModule</span> !== <span class="string">&quot;undefined&quot;</span> ? options.<span class="property">esModule</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回模块化内容</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    esModule ? <span class="string">&quot;export default&quot;</span> : <span class="string">&quot;module.exports =&quot;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span> <span class="subst">$&#123;publicPath&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码使用 <code>loader-utils</code> 提供的 <code>interpolateName</code> 在 <code>file-loader</code> 中获取资源写出的路径及名称，核心逻辑：</p>
<ul>
<li><p>根据 Loader 配置，调用 <code>interpolateName</code> 方法拼接目标文件的完整路径</p>
</li>
<li><p>调用上下文 <code>this.emitFile</code> 接口，写出文件</p>
</li>
<li><p>返回 <code>module.exports = $&#123;publicPath&#125;</code> ，其它模块可以引用到该文件路径</p>
</li>
</ul>
</li>
<li><p>单元测试</p>
<p>Webpack Loader 场景下常用的单元测试流程，以 Jest · Delightful JavaScript Testing 为例：</p>
<ol>
<li>创建在 Webpack 实例，并运行 Loader</li>
<li>获取 Loader 执行结果，比对、分析判断是否符合预期</li>
<li>判断执行过程中是否出错</li>
</ol>
<p>先在 node 环境下运行调用 Webpack 接口，用代码而非命令行执行编译，很多框架都会采用这种方式。以 posthtml&#x2F;posthtml-loader 为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// posthtml-loader/test/helpers/compiler.js 文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">fixture, config, options</span>) &#123;</span><br><span class="line">  config = &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">output</span>: <span class="literal">false</span> &#125;, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Webpack 实例</span></span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="title function_">webpack</span>(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以 MemoryFS 方式输出构建结果，避免写磁盘</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">output</span>) compiler.<span class="property">outputFileSystem</span> = <span class="keyword">new</span> <span class="title class_">MemoryFS</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行，并以 promise 方式返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    compiler.<span class="title function_">run</span>(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="comment">// 异步返回执行结果</span></span><br><span class="line">      <span class="title function_">resolve</span>(stats);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它会在启动测试之前创建并运行 Webpack 实例。用 <code>compiler.outputFileSystem = new MemoryFS()</code> 语句将 Webpack 设定成输出到内存，能避免写盘操作，提升编译速度。</p>
<p>下一步是比对结果，上例运行结束之后会以 <code>resolve(stats)</code> 方式返回执行结果，<code>stats</code> 对象中几乎包含了编译过程所有信息，包括耗时、产物、模块、chunks、errors、warnings 等等。</p>
<p>可以从 <code>stats</code> 对象中读取编译最终输出的产物，例如 style-loader 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// style-loader/src/test/helpers/readAsset.js 文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readAsset</span>(<span class="params">compiler, stats, assets</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> usedFs = compiler.<span class="property">outputFileSystem</span></span><br><span class="line">  <span class="keyword">const</span> outputPath = stats.<span class="property">compilation</span>.<span class="property">outputOptions</span>.<span class="property">path</span></span><br><span class="line">  <span class="keyword">const</span> queryStringIdx = targetFile.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queryStringIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析出输出文件路径</span></span><br><span class="line">    asset = asset.<span class="title function_">substr</span>(<span class="number">0</span>, queryStringIdx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读文件内容</span></span><br><span class="line">  <span class="keyword">return</span> usedFs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(outputPath, targetFile)).<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先计算 asset 输出的文件路径，之后调用 outputFileSystem 的 <code>readFile</code> 方法读取文件内容。</p>
<p>接下来，有两种分析内容的方法：</p>
<ul>
<li>调用 Jest 的 <code>expect(xxx).toMatchSnapshot()</code> 断言判断当前运行结果是否与之前的运行结果一致，从而确保多次修改的结果一致性，很多框架都大量用了这种方法</li>
<li>解读资源内容，判断是否符合预期，例如 less-loader 的单元测试中会对同一份代码跑两次 less 编译，一次由 Webpack 执行，一次直接调用 <code>less</code> 库，之后分析两次运行结果是否相同</li>
</ul>
<p>最后，还需要判断编译过程是否出现异常，同样可以从 <code>stats</code> 对象解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getErrors = <span class="function">(<span class="params">stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errors = stats.<span class="property">compilation</span>.<span class="property">errors</span>.<span class="title function_">sort</span>();</span><br><span class="line">  <span class="keyword">return</span> errors.<span class="title function_">map</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大多数情况下都希望编译没有错误，此时只要判断结果数组是否为空即可。某些情况下可能需要判断是否抛出特定异常，此时可以 <code>expect(xxx).toMatchSnapshot()</code> 断言，用快照对比更新前后的结果。</p>
</li>
<li><p>调试</p>
<p>开发 Loader 的过程中，有一些小技巧能够提升调试效率，包括：</p>
<ul>
<li>使用 ndb 工具实现断点调试</li>
<li>使用 <code>npm link</code> 将 Loader 模块链接到测试项目</li>
<li>使用 <code>resolveLoader</code> 配置项将 Loader 所在的目录加入到测试项目中，如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">resolveLoader</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&quot;node_modules&quot;</span>, <span class="string">&quot;./loaders/&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、项目优化"><a href="#二、项目优化" class="headerlink" title="二、项目优化"></a>二、<strong>项目优化</strong></h2><h3 id="1、优化方面"><a href="#1、优化方面" class="headerlink" title="1、优化方面"></a>1、<strong>优化方面</strong></h3><ul>
<li><p>页面性能优化</p>
<ul>
<li><p>缩小打包文件体积：可以通过 Tree Shaking 和 Code Splitting 等技术，去除应用程序中未使用的代码和模块，减小打包后文件的体积。</p>
</li>
<li><p>优化加载速度：可以使用 Webpack 的懒加载功能，在需要时再加载某些模块或代码，提高应用程序的加载速度。</p>
</li>
<li><p>按需加载：可以使用 Webpack 的按需加载功能，根据路由或事件等条件，动态加载模块或代码，提高应用程序的加载速度。</p>
</li>
<li><p>压缩代码：压缩打包后的代码，可以减少文件大小，提高加载速度。webpack 4.x 版本开始，默认情况下会在生产模式下进行代码压缩。</p>
</li>
<li><p>使用 CDN：可以将静态资源文件放到 CDN 上，以减轻服务器的负载，提高访问速度。</p>
</li>
</ul>
</li>
<li><p>构建速度优化</p>
<ul>
<li>使用缓存：可以使用 Webpack 的缓存功能，将已经打包好的模块或代码缓存起来，减少重复打包的时间。如：使用 Webpack 的 cache-loader 或 hard-source-webpack-plugin 插件，将已经打包好的模块或代码缓存起来，减少重复打包的时间。</li>
<li>并行打包，发挥多核 CPU 能力：可以使用 Webpack 的 HappyPack 插件，将打包任务分解成多个子任务并行处理，提高打包速度。</li>
</ul>
</li>
</ul>
<h3 id="2、Tree-Shaking"><a href="#2、Tree-Shaking" class="headerlink" title="2、Tree Shaking"></a>2、Tree Shaking</h3><blockquote>
<p>Tree Shaking 依赖于 ES6 模块语法<code>import</code> 和<code>export</code>，在 webpack 中它的功能是默认开启的。</p>
</blockquote>
<p>需要注意：</p>
<ul>
<li>Tree Shaking 只能移除没有副作用的代码，如果代码中存在副作用，那么这部分代码将无法被移除。</li>
<li>在 vue2.x 项目中，对公共组件的引入，要单独引入，而不是通过 index 文件统一暴露其内部的组件。<ul>
<li>如，要<code>import TestComponents1 from &#39;/src/components/TestComponents1.vue&#39;</code>这样单独引入组件，而不是<code>import &#123; TestComponents1 &#125; from &#39;/src/components&#39;</code>。</li>
</ul>
</li>
</ul>
<h3 id="3、Code-Splitting"><a href="#3、Code-Splitting" class="headerlink" title="3、Code Splitting"></a>3、Code Splitting</h3><p>SplitChunksPlugin 是 Webpack 4 之后引入的分包方案(此前为 <code>CommonsChunkPlugin</code>)，它能够基于一些启发式的规则将 Module 编排进不同的 Chunk 序列，并最终将应用代码分门别类打包出多份产物，从而实现分包功能。</p>
<h5 id="i-内置的默认规则"><a href="#i-内置的默认规则" class="headerlink" title="i. 内置的默认规则"></a>i. 内置的默认规则</h5><p><code>SplitChunksPlugin</code> 内置了 <code>default</code> 与 <code>defaultVendors</code> 两个配置组，提供一些开箱即用的特性：</p>
<ul>
<li><code>node_modules</code> 资源会命中 <code>defaultVendors</code> 规则，并被单独打包</li>
<li>只有包体超过 20kb 的 Chunk 才会被单独打包</li>
<li>加载 Async Chunk 所需请求数不得超过 30</li>
<li>加载 Initial Chunk 所需请求数不得超过 30</li>
</ul>
<p>即：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">20000</span>,</span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">defaultVendors</span>: &#123;</span><br><span class="line">          <span class="attr">idHint</span>: <span class="string">&quot;vendors&quot;</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/i</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="attr">idHint</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个配置组能帮助我们：</p>
<ul>
<li>将所有 <code>node_modules</code> 中的资源单独打包到 <code>vendors-xxx-xx.js</code> 命名的产物</li>
<li>对引用次数大于等于 2 的模块，也就是被多个 Chunk 引用的模块，单独打包</li>
</ul>
<h5 id="ii-分包场景"><a href="#ii-分包场景" class="headerlink" title="ii. 分包场景"></a>ii. 分包场景</h5><ol>
<li><p>根据 Module 使用频率分包。</p>
<p>可通过 <code>optimization.splitChunks.minChunks</code> 设定最小引用次数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="comment">// 设定引用次数&gt;=2的模块才进行分包</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假如，代码包含四个模块，形成如下模块关系图：</p>
<p><img src="/./images/23-4-14/640.png" alt="640"></p>
<p>对于 <code>common</code> 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，命中 <code>optimization.splitChunks.minChunks = 2</code> 规则，因此该模块<strong>可能</strong>会被单独分包：</p>
<ul>
<li>entry-a.js</li>
<li>entry-b.js</li>
<li>async-module.js</li>
<li>common.js</li>
</ul>
</li>
<li><p>限制分包数量。</p>
<p>在满足 <code>minChunks</code> 基础上，还可以通过 <code>maxInitialRequest/maxAsyncRequests</code> 配置项限定分包数量，配置项语义：</p>
<ul>
<li>maxInitialRequest：用于设置 Initial Chunk 最大并行请求数</li>
<li>maxAsyncRequests：用于设置 Async Chunk 最大并行请求数</li>
</ul>
<p>这里所说的“请求数”，是指加载一个 Chunk 时所需同步加载的分包数。</p>
<p>如，而对于下述模块关系：</p>
<p><img src="/./images/23-4-14/642.png" alt="642"></p>
<p>若 <code>minChunks = 2</code> ，则 <code>common-1</code> 、<code>common-2</code> 同时命中 <code>minChunks</code> 规则被分别打包。而浏览器请求 <code>entry-b</code> 时需要同时请求 <code>common-1</code> 、<code>common-2</code> 两个分包，并行数为 2 + 1 &#x3D; 3，此时若 <code>maxInitialRequest = 2</code>，则分包数超过阈值，<code>SplitChunksPlugin</code> 会放弃 <code>common-1</code> 、<code>common-2</code> 中体积较小的分包。</p>
<p><code>syncRequest</code> 逻辑与此类似。</p>
<p>并行请求数关键逻辑总结如下：</p>
<ul>
<li>Initial Chunk 本身算一个请求</li>
<li>Async Chunk 不算并行请求</li>
<li>通过 <code>runtimeChunk</code> 拆分出的 runtime 不算并行请求</li>
<li>如果同时有两个 Chunk 满足拆分规则，但是 <code>maxInitialRequests</code>(或 <code>maxAsyncRequest</code>) 的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解</li>
</ul>
</li>
<li><p>限制分包体积</p>
<p>在满足 <code>minChunks</code> 与 <code>maxInitialRequests</code> 的基础上，<code>SplitChunksPlugin</code> 还会进一步判断 Chunk 包大小决定是否分包，这一规则相关的配置项非常多：</p>
<ul>
<li><code>minSize</code>：超过这个尺寸的 Chunk 才会正式被分包</li>
<li><code>maxSize</code>：超过这个尺寸的 Chunk 会尝试继续做分包</li>
<li><code>maxAsyncSize</code>：与 <code>maxSize</code> 功能类似，但只对异步引入的模块生效</li>
<li><code>maxInitialSize</code>：与 <code>maxSize</code> 类似，但只对 <code>entry</code> 配置的入口模块生效</li>
<li><code>enforceSizeThreshold</code>：超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制</li>
</ul>
<p>同样以下图模块关系为例：</p>
<p><img src="/./images/23-4-14/640.png" alt="640"></p>
<p>若此时 Webpack 配置的 <code>minChunks</code> 大于 2，且 <code>maxInitialRequests</code> 也同样大于 2。如果 <code>common</code> 模块的体积大于上述说明的 <code>minxSize</code> 配置项则分包成功，<code>commont</code> 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。</p>
</li>
<li><p>总结</p>
<p>那么，结合前面介绍的 1-3，<code>SplitChunksPlugin</code> 的主体流程如下：</p>
<ul>
<li><p><code>SplitChunksPlugin</code> 尝试将命中 <code>minChunks</code> 规则的 Module 统一抽到一个额外的 Chunk 对象；</p>
</li>
<li><p>判断该 Chunk 是否满足 <code>maxInitialRequests</code> 阈值，若满足则进行下一步</p>
</li>
<li><p>判断该 Chunk 资源的体积是否大于上述配置项 <code>minSize</code> 声明的下限阈值；</p>
<ul>
<li>如果体积<strong>小于</strong> <code>minSize</code> 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk</li>
<li>如果 Chunk 体积<strong>大于</strong> <code>minSize</code> 则判断是否超过 <code>maxSize</code>、<code>maxAsyncSize</code>、<code>maxInitialSize</code> 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="iii-缓存组"><a href="#iii-缓存组" class="headerlink" title="iii. 缓存组"></a>iii. 缓存组</h5><p>除上述 <code>minChunks</code>、<code>maxInitialRequest</code>、<code>minSize</code> 等基础规则外，<code>SplitChunksPlugin</code> 还提供了 <code>cacheGroups</code> 配置项用于为不同文件组设置不同的规则。</p>
<p><code>cacheGroups</code> 支持一些与分组逻辑强相关的属性，包括：</p>
<ul>
<li>test：接受正则表达式、函数及字符串，所有符合 <code>test</code> 判断的 Module 或 Chunk 都会被分到该组</li>
<li>type：接受正则表达式、函数及字符串，与 <code>test</code> 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 <code>type = &#39;json&#39;</code> 会命中所有 JSON 文件</li>
<li>idHint：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 <code>idHint = &#39;vendors&#39;</code> 时，输出产物文件名形如 <code>vendors-xxx-xxx.js</code></li>
<li>priority：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 <code>priority</code> 更大的组</li>
</ul>
<h5 id="iv-最佳实践"><a href="#iv-最佳实践" class="headerlink" title="iv. 最佳实践"></a>iv. 最佳实践</h5><ul>
<li>尽量将 第三方库 和 公共逻辑的代码(如果包够大) 拆为独立分包</li>
<li>保持按路由分包，减少首屏资源负载</li>
<li><code>optimization.splitChunks.chunks</code> 配置项用于设置 <code>SplitChunksPlugin</code> 的工作范围，我们应该尽量保持 <code>chunks = &#39;all&#39;</code> 从而最大程度优化分包逻辑</li>
</ul>
<h3 id="4、懒加载或按需加载"><a href="#4、懒加载或按需加载" class="headerlink" title="4、懒加载或按需加载"></a>4、懒加载或按需加载</h3><p>懒加载和按需加载都可以通过 Webpack 的 Code Splitting 功能来实现。Code Splitting 可以将一个大的 JavaScript 文件拆分成多个小的 JavaScript 文件，然后按需加载这些文件，从而实现按需加载和懒加载的效果。</p>
<p>如下示例，实现了按需加载一个 echart.js 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">import</span>(<span class="string">&quot;./echart.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> print = <span class="variable language_">module</span>.<span class="property">default</span>;</span><br><span class="line">      <span class="title function_">print</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickHandler&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        点我按需加载echart.js文件</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由懒加载同样原理。</p>
<h3 id="5、使用缓存提升构建速度"><a href="#5、使用缓存提升构建速度" class="headerlink" title="5、使用缓存提升构建速度"></a>5、<strong>使用缓存提升构建速度</strong></h3><h5 id="i-持久化缓存"><a href="#i-持久化缓存" class="headerlink" title="i. 持久化缓存"></a>i. 持久化缓存</h5><p>webpack 之后，Vite、SnowPack 等以性能著称的同类框架在业内掀起不小波澜，为此，Webpack5 引入了持久化缓存，以用于提升运行性能。</p>
<p>Webpack5 会将首次构建结果持久化到本地文件系统， 如 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，在下次执行构建时跳过执行 Loader 链、解析 AST、解析依赖等非常消耗性能的操作，直接复用 module、chunk 的构建结果，以提升编译性能。</p>
<p>可简单通过如下代码，即可开启：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;filesystem&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="ii-使用缓存"><a href="#ii-使用缓存" class="headerlink" title="ii. 使用缓存"></a>ii. 使用缓存</h5><p><code>cache</code> 提供的<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/cache">配置项列表</a>，下面列出几个比较常用的配置项：</p>
<ul>
<li><p><code>cache.type</code>：缓存类型，支持 <code>&#39;memory&#39; | &#39;filesystem&#39;</code>，需要设置 <code>filesystem</code> 才能开启持久缓存</p>
</li>
<li><p><code>cache.cacheDirectory</code>：缓存文件存放的路径，默认为 <code>node_modules/.cache/webpack</code></p>
</li>
<li><p><code>cache.buildDependencies</code>：额外的依赖文件，当这些文件内容发生变化时，缓存会完全失效而执行完整的编译构建，通常可设置为项目配置文件，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">buildDependencies</span>: &#123;</span><br><span class="line">      <span class="attr">config</span>: [path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;webpack.dll_config.js&quot;</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cache.managedPaths</code>：受控目录，Webpack 构建时会跳过新旧代码哈希值与时间戳的对比，直接使用缓存副本，默认值为 <code>[&#39;./node_modules&#39;]</code></p>
</li>
<li><p><code>cache.profile</code>：是否输出缓存处理过程的详细日志，默认为 <code>false</code></p>
</li>
<li><p><code>cache.maxAge</code>：缓存失效时间，默认值为 <code>5184000000</code></p>
</li>
</ul>
<p>使用时通常关注上述配置项即可。</p>
<h5 id="iii-webpack4-中的缓存"><a href="#iii-webpack4-中的缓存" class="headerlink" title="iii. webpack4 中的缓存"></a>iii. webpack4 中的缓存</h5><p>webpack4 中已经内置使用内存实现的临时缓存功能，但必须在 <code>watch</code> 模式下使用，进程退出后立即失效，实用性不高。但在 Webpack 4 及之前版本中可以使用一些 <code>loader</code> 自带的缓存功能提升构建性能，例如 <code>babel-loader</code>、<code>eslint-loader</code>、<code>cache-loader</code> 。</p>
<p>开启<code>babel-loader</code>缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>开启<code>eslint-loader</code>缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除 <code>babel-loader</code>、<code>eslint-loader</code> 这类特化 loader 自身携带的缓存功能外，Webpack 4 中还可以使用 <code>cache-loader</code> 实现与 Webpack 5 相似的通用持久化缓存功能，使用上只需将 <code>cache-loader</code> 配置在 <code>loader</code> 数组首位，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;cache-loader&quot;</span>, <span class="string">&quot;babel-loader&quot;</span>, <span class="string">&quot;eslint-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与 Webpack 5 自带的持久化缓存不同，<code>cache-loader</code> 仅 Loader 执行结果有效，缓存范围与深度不如内置的缓存功能，所以性能收益相对较低，但在 Webpack 4 版本下已经不失为一种简单而有效的性能优化手段。</p>
<h3 id="6、利用多进程提升构建速度"><a href="#6、利用多进程提升构建速度" class="headerlink" title="6、利用多进程提升构建速度"></a>6、<strong>利用多进程提升构建速度</strong></h3><p>并行的本质则是在同一时间内并发执行多个运算，提升单位时间计算效率，两者都是计算机科学常见的提升性能优化手段。</p>
<p>受限于 Node.js 的单线程架构，原生 Webpack 对所有资源文件做的所有解析、转译、合并操作本质上都是在同一个线程内串行执行，CPU 利用率极低，因此，理所当然地社区出现了一些基于多进程方式运行 Webpack，或 Webpack 构建过程某部分工作的方案，例如：</p>
<ul>
<li>HappyPack：多进程方式运行资源加载逻辑</li>
<li>Thread-loader：Webpack 官方出品，同样以多进程方式运行资源加载逻辑</li>
<li>TerserWebpackPlugin：支持多进程方式执行代码压缩、uglify 功能</li>
<li>Parallel-Webpack：多进程方式运行多个 Webpack 构建实例</li>
</ul>
<h5 id="i-Happypack"><a href="#i-Happypack" class="headerlink" title="i. Happypack"></a>i. Happypack</h5><p>基本用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 使用 happypack/loader 替换原来的 Loader 配置</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;happypack/loader&quot;</span>,</span><br><span class="line">        <span class="comment">// use: [</span></span><br><span class="line">        <span class="comment">//  &#123;</span></span><br><span class="line">        <span class="comment">//      loader: &#x27;babel-loader&#x27;,</span></span><br><span class="line">        <span class="comment">//      options: &#123;</span></span><br><span class="line">        <span class="comment">//          presets: [&#x27;@babel/preset-env&#x27;]</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">//  &#125;,</span></span><br><span class="line">        <span class="comment">//  &#x27;eslint-loader&#x27;</span></span><br><span class="line">        <span class="comment">// ]</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">loaders</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">          <span class="attr">option</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述简单示例只能以相同的 Loader 序列处理同种文件类型，实际应用中还可以为不同的文件配置多个 相应的加载器数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HappyPack</span> = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;happypack/loader?id=js&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;happypack/loader?id=styles&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;js&quot;</span>,</span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;babel-loader&quot;</span>, <span class="string">&quot;eslint-loader&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;styles&quot;</span>,</span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，HappyPack 插件实例各自管理自身所消费的进程，导致整体需要维护一个数量庞大的进程池，反而带来新的性能损耗。</p>
<p>为此，HappyPack 提供了一套简单易用的共享进程池功能，使用上只需创建 <code>HappyPack.ThreadPool</code> 实例并通过 <code>size</code> 参数限定进程总量，之后将该实例配置到各个 HappyPack 插件的 <code>threadPool</code> 属性上即可，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HappyPack</span> = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = <span class="title class_">HappyPack</span>.<span class="title class_">ThreadPool</span>(&#123;</span><br><span class="line">  <span class="attr">size</span>: os.<span class="title function_">cpus</span>().<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;js&quot;</span>,</span><br><span class="line">      <span class="attr">threadPool</span>: happyThreadPool,</span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;babel-loader&quot;</span>, <span class="string">&quot;eslint-loader&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;styles&quot;</span>,</span><br><span class="line">      <span class="attr">threadPool</span>: happyThreadPool,</span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用共享进程池功能后，HappyPack 会预先创建好一组共享的 <code>HappyThread</code> 对象，所有插件实例的资源转译需求最终都会通过 <code>HappyThread</code> 对象转发到空闲进程做处理，从而保证整体进程数量可控。</p>
<h5 id="ii-Thread-loader"><a href="#ii-Thread-loader" class="headerlink" title="ii. Thread-loader"></a>ii. Thread-loader</h5><p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;thread-loader&quot;</span>, <span class="string">&quot;babel-loader&quot;</span>, <span class="string">&quot;eslint-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="iii-Parallel-Webpack"><a href="#iii-Parallel-Webpack" class="headerlink" title="iii. Parallel-Webpack"></a>iii. Parallel-Webpack</h5><p>Thread-loader、HappyPack 这类组件所提供的并行能力都仅作用于执行加载器 —— Loader 的过程，对后续 AST 解析、依赖收集、打包、优化代码等过程均没有影响，理论收益还是比较有限的。对此，社区还提供了另一种并行度更高，以多个独立进程运行 Webpack 实例的方案 —— Parallel-Webpack。</p>
<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;pageA.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;pageA.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;pageB.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;pageB.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>执行命令 <code>npx parallel-webpack</code> 即可完成构建，上面的示例配置会同时打包出 <code>pageA.js</code> 与 <code>pageB.js</code> 两份产物。</p>
<h5 id="iv-并行压缩"><a href="#iv-并行压缩" class="headerlink" title="iv. 并行压缩"></a>iv. 并行压缩</h5><p>Webpack 下通常使用 Uglify-js、Uglify-es、Terser 做代码混淆压缩，三者都不同程度上原生实现了多进程并行压缩功能。</p>
<p>以 Terser 为例，插件 TerserWebpackPlugin 默认已开启并行压缩能力，通常情况下保持默认配置即 <code>parallel = true</code> 即可获得最佳的性能收益。开发者也可以通过 <code>parallel</code> 参数关闭或设定具体的并行进程数量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="number">2</span>, <span class="comment">// number | boolean</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述配置即可设定最大并行进程数为 2。</p>
<h5 id="v-最佳实践"><a href="#v-最佳实践" class="headerlink" title="v. 最佳实践"></a>v. 最佳实践</h5><p>理论上，并行确实能够提升系统运行效率，但 Node 单线程架构下，所谓的并行计算都只能依托与派生子进程执行，而创建进程这个动作本身就有不小的消耗 —— 大约 600ms，因此建议读者按实际需求斟酌使用上述多进程方案。</p>
<p>对于小型项目，构建成本可能很低，但引入多进程技术反而导致整体成本增加。</p>
<p>对于大型项目，由于 HappyPack 官方已经明确表示不维护，所以建议尽量使用 Thread-loader 组件提升 Make 阶段性能。生产环境下还可配合 terser-webpack-plugin 的并行压缩功能，提升整体效率。</p>
<h3 id="7、提升编译性能"><a href="#7、提升编译性能" class="headerlink" title="7、提升编译性能"></a>7、提升编译性能</h3><h5 id="i-使用最近版本"><a href="#i-使用最近版本" class="headerlink" title="i. 使用最近版本"></a>i. 使用最近版本</h5><p>从 Webpack V3，到 V4，再到最新的 V5 版本，虽然构建功能在不断叠加增强，但性能反而不断优化提升。</p>
<ul>
<li>V3 到 V4 重写 Chunk 依赖逻辑，将原来的父子树状关系调整为 <code>ChunkGroup</code> 表达的有序图关系，提升代码分包效率</li>
<li>V4 到 V5 引入 <code>cache</code> 功能，支持将模块、模块关系图、产物等核心要素持久化缓存到硬盘，减少重复工作</li>
</ul>
<h5 id="ii-缩小资源搜索范围"><a href="#ii-缩小资源搜索范围" class="headerlink" title="ii. 缩小资源搜索范围"></a>ii. 缩小资源搜索范围</h5><p>Webpack 默认提供了一套同时兼容 CMD、AMD、ESM 等模块化方案的资源搜索规则 —— <a target="_blank" rel="noopener" href="https://github.com/webpack/enhanced-resolve">enhanced-resolve</a>，它能将各种模块导入语句准确定位到模块对应的物理资源路径。</p>
<p>如：</p>
<ul>
<li><code>import &#39;lodash&#39;</code> 这一类引入 npm 包的语句会被 <code>enhanced-resolve</code> 定位到对应包体文件路径 <code>node_modules/lodash/index.js</code> ；</li>
<li><code>import &#39;./a&#39;</code> 这类不带文件后缀名的语句则可能被定位到 <code>./a.js</code> 文件；</li>
<li><code>import &#39;``@/a&#39;</code> 这类化名路径的引用则可能被定位到 <code>$PROJECT_ROOT/src/a.js</code> 文件。</li>
</ul>
<p>这类增强资源搜索体验的特性背后涉及许多 IO 操作，本身可能引起较大的性能消耗，开发者可根据实际情况调整 <code>resolve</code> 配置，缩小资源搜索范围：</p>
<ol>
<li><p><code>resolve.extensions</code>配置</p>
<p>如，在 Webpack 5 中，<code>resolve.extensions</code> 默认值为 <code>[&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;]</code> ，这意味着 Webpack 在针对不带后缀名的引入语句时可能需要执行三次判断逻辑才能完成文件搜索，所以可以考虑如下优化：</p>
<ul>
<li>修改 <code>resolve.extensions</code> 配置项，减少匹配次数</li>
<li>代码中尽量补齐文件后缀名</li>
<li>设置 <code>resolve.enforceExtension = true</code> ，强制要求开发者提供明确的模块后缀名，这种做法侵入性太强，不太推荐</li>
</ul>
</li>
<li><p><code>resolve.modules</code>配置</p>
<p>如，当 Webpack 遇到 <code>import &#39;lodash&#39;</code> 这样的 npm 包导入语句时，会尝试先当前项目的 <code>node_modules</code> 搜索资源，如果找不到则按目录层级尝试逐级向上查找 <code>node_modules</code> 目录，如果依然找不到则最终尝试在全局 <code>node_modules</code> 中搜索。（可参考<a target="_blank" rel="noopener" href="https://souche.yuque.com/beijing-myye7/wireless/sbeg5w#2cfc019c%EF%BC%89">https://souche.yuque.com/beijing-myye7/wireless/sbeg5w#2cfc019c）</a></p>
<p>所以，我们通常会尽量保持 <code>node_modules</code> 资源的高度内聚，控制在有限的一两个层级上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;node_modules&quot;</span>)],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>resolve.mainFiles</code>配置</p>
<p>与 <code>resolve.extensions</code> 类似，<code>resolve.mainFiles</code> 配置项用于定义文件夹默认文件名，例如对于 <code>import &#39;./dir&#39;</code> 请求，假设 <code>resolve.mainFiles = [&#39;index&#39;, &#39;home&#39;]</code> ，Webpack 会按依次测试 <code>./dir/index</code> 与 <code>./dir/home</code> 文件是否存在。</p>
<p>所以，应控制 <code>resolve.mainFiles</code> 数组数量，减少匹配次数。</p>
</li>
</ol>
<h5 id="iii-跳过文件编译"><a href="#iii-跳过文件编译" class="headerlink" title="iii. 跳过文件编译"></a>iii. 跳过文件编译</h5><p>第三方依赖 npm 包默认提供了提前打包好，不需要做二次编译的资源版本，此时可以使用 <code>module.noParse</code> 配置项跳过这些 npm 包，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/vue|lodash|react/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="iv-最小化-Loader-作用范围"><a href="#iv-最小化-Loader-作用范围" class="headerlink" title="iv. 最小化 Loader 作用范围"></a>iv. 最小化 Loader 作用范围</h5><p>Loader 在执行内容转换的过程可能需要做大量的 CPU 运算操作，例如 babel-loader、eslint-loader、vue-loader 等，因此开发者有必要根据实际需求，通过 <code>module.rules.include</code>、<code>module.rules.exclude</code> 等配置项限定 Loader 的执行范围，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// include: path.join(__dirname, &#x27;./src&#x27;),</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&quot;babel-loader&quot;</span>, <span class="string">&quot;eslint-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="v-最小化-watch-监控范围"><a href="#v-最小化-watch-监控范围" class="headerlink" title="v. 最小化 watch 监控范围"></a>v. 最小化 watch 监控范围</h5><p>在 watch 模式下(通过 <code>npx webpack --watch</code> 命令启动)，Webpack 会持续监听项目所有代码文件，发生变化时重新构建最新产物。不过，通常情况下前端项目中某些资源并不会频繁更新，例如 <code>node_modules</code> ，此时可以设置 <code>watchOptions.ignored</code> 属性忽略这些文件，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="vi-跳过-TS-类型检查"><a href="#vi-跳过-TS-类型检查" class="headerlink" title="vi. 跳过 TS 类型检查"></a>vi. 跳过 TS 类型检查</h5><p>TypeScript 类型检查涉及 AST 解析、遍历以及其它非常消耗 CPU 的操作，会给工程化流程引入性能负担，必要时开发者可选择关闭编译主进程中的类型检查功能，同步用 <code>fork-ts-checker-webpack-plugin</code> 插件将其剥离到单独进程执行，例如对于 <code>ts-loader</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ForkTsCheckerWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;fork-ts-checker-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">transpileOnly</span>: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">ForkTsCheckerWebpackPlugin</span>()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="vii-慎用-source-map"><a href="#vii-慎用-source-map" class="headerlink" title="vii. 慎用 source-map"></a>vii. 慎用 source-map</h5><p><code>source-map</code> 是一种将经过编译、压缩、混淆的代码代码映射回源码的技术，它能够帮助开发者迅速定位到更有意义、更结构化的源码中，方便调试。不过，同样的 <code>source-map</code> 操作本身也有很大性能开销，建议读者根据实际场景慎重选择最合适的 <code>source-map</code> 方案。</p>
<p>针对 <code>source-map</code> 功能，Webpack 提供了 <code>devtool</code> 选项，可以配置 <code>eval</code>、<code>source-map</code>、<code>cheap-source-map</code> 等值，不考虑其它因素的情况下，最佳实践：</p>
<ul>
<li>开发环境使用 <code>eval</code> ，确保最佳编译速度</li>
<li>生产环境使用 <code>source-map</code>，获取最高质量</li>
</ul>
<h3 id="8、babel-plugin-lodash、lodash-webpack-plugin"><a href="#8、babel-plugin-lodash、lodash-webpack-plugin" class="headerlink" title="8、babel-plugin-lodash、lodash-webpack-plugin"></a>8、babel-plugin-lodash、lodash-webpack-plugin</h3><p>&#96;&#96;babel-plugin-lodash<code>和</code>lodash-webpack-plugin&#96;都是用于优化 Lodash 库的 Webpack 插件。（详细用法参考<a target="_blank" rel="noopener" href="https://souche.yuque.com/beijing-myye7/wireless/8b92718db0d47f4340d10e88890584d6#ToDcW%EF%BC%89">https://souche.yuque.com/beijing-myye7/wireless/8b92718db0d47f4340d10e88890584d6#ToDcW）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jasonchan27.github.io/2023/04/14/webpack%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/" data-id="clggg6vm1003bolzk2ubl0sbe" data-title="webpack 实践总结" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/" rel="tag">前端实践</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/10/31/PC%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%B1%E7%94%A8%E4%B8%80%E5%A5%97%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">PC 端和移动端共用一套代码的可行性分析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/" rel="tag">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/" rel="tag">React合成事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React%E5%9F%BA%E7%A1%80/" rel="tag">React基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/State%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/" rel="tag">State更新原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/style-component/" rel="tag">style-component</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vdom/" rel="tag">vdom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/" rel="tag">前端实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/" rel="tag">模块机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/" rel="tag">移动端兼容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%82%E9%85%8D/" rel="tag">适配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" rel="tag">项目中遇到的问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS3/" style="font-size: 10px;">CSS3</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/Hybrid/" style="font-size: 10px;">Hybrid</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/React/" style="font-size: 20px;">React</a> <a href="/tags/React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">React合成事件</a> <a href="/tags/React%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">React基础</a> <a href="/tags/State%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/" style="font-size: 10px;">State更新原理</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/style-component/" style="font-size: 10px;">style-component</a> <a href="/tags/vdom/" style="font-size: 10px;">vdom</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/" style="font-size: 13.33px;">前端实践</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">原型链</a> <a href="/tags/%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">模块机制</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/" style="font-size: 13.33px;">移动端兼容</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%80%82%E9%85%8D/" style="font-size: 13.33px;">适配</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 13.33px;">项目</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" style="font-size: 16.67px;">项目中遇到的问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/14/webpack%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">webpack 实践总结</a>
          </li>
        
          <li>
            <a href="/2022/10/31/PC%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%B1%E7%94%A8%E4%B8%80%E5%A5%97%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90/">PC 端和移动端共用一套代码的可行性分析</a>
          </li>
        
          <li>
            <a href="/2022/05/05/Node%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/">Node 模块机制</a>
          </li>
        
          <li>
            <a href="/2022/04/12/h5%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E5%92%8C%E9%80%82%E9%85%8D%E6%80%BB%E7%BB%93/">h5 兼容问题和适配总结</a>
          </li>
        
          <li>
            <a href="/2021/09/05/React%20State%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/">React State更新原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jason Chan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>


<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.JPG">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jason Chan">
  <meta name="keywords" content="笔记,博客">
  
    <meta name="description" content="一、基础相关优化1、减少回流（重排）和重绘i、回流（重排）触发条件 当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流（重排）。  下面这些操作会导致回流（重排）：  页面的首次渲染 浏览器的窗口大小发生变化 元素的内容发生变化 元素的尺寸或者位置发生变化 元素的字体大小发生变化 激活 CSS 伪类 查询某些属性或者调用某些方法 client">
<meta property="og:type" content="article">
<meta property="og:title" content="性能优化实践总结">
<meta property="og:url" content="https://jasonchan27.github.io/2023/08/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Jason的笔记">
<meta property="og:description" content="一、基础相关优化1、减少回流（重排）和重绘i、回流（重排）触发条件 当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流（重排）。  下面这些操作会导致回流（重排）：  页面的首次渲染 浏览器的窗口大小发生变化 元素的内容发生变化 元素的尺寸或者位置发生变化 元素的字体大小发生变化 激活 CSS 伪类 查询某些属性或者调用某些方法 client">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-28T01:48:27.000Z">
<meta property="article:modified_time" content="2023-08-30T08:37:24.660Z">
<meta property="article:author" content="Jason Chan">
<meta property="article:tag" content="性能优化">
<meta property="article:tag" content="实践">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>性能优化实践总结 - Jason的笔记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jasonchan27.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"UsaXddA42sfhvk7QGhCaqFp4-gzGzoHsz","app_key":"6VmPvhwsZaqK74sTVXv7PP8K","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Jason&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="性能优化实践总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-28 09:48" pubdate>
          2023年8月28日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          340 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">性能优化实践总结</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、基础相关优化"><a href="#一、基础相关优化" class="headerlink" title="一、基础相关优化"></a>一、基础相关优化</h1><h2 id="1、减少回流（重排）和重绘"><a href="#1、减少回流（重排）和重绘" class="headerlink" title="1、减少回流（重排）和重绘"></a>1、减少回流（重排）和重绘</h2><h5 id="i、回流（重排）触发条件"><a href="#i、回流（重排）触发条件" class="headerlink" title="i、回流（重排）触发条件"></a>i、回流（重排）触发条件</h5><blockquote>
<p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流（重排）。</p>
</blockquote>
<p>下面这些操作会导致回流（重排）：</p>
<ul>
<li>页面的首次渲染</li>
<li>浏览器的窗口大小发生变化</li>
<li>元素的内容发生变化</li>
<li>元素的尺寸或者位置发生变化</li>
<li>元素的字体大小发生变化</li>
<li>激活 CSS 伪类</li>
<li>查询某些属性或者调用某些方法<ul>
<li>clientWidth、clientHeight ：读取这些属性会获取元素可见区域的宽度和高度，不会引起回流。</li>
<li>clientTop、clientLeft ：读取这些属性会获取元素的内边距的大小，不会触发回流。</li>
<li>scrollWidth、scrollHeight ：读取这些属性会获取元素内容区域的宽度和高度，不会引起回流。</li>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight ：读取这些属性会触发浏览器计算元素的布局，可能引发回流。</li>
<li>getComputedStyle() ：调用此方法可以获取元素的计算样式，由于需要获取实时计算后的样式，可能会触发回流。</li>
<li>getBoundingClientRect() ：调用此方法会获取元素在视口中的位置和尺寸信息，这将触发回流。</li>
<li>offsetParent ：读取这个属性会触发回流。</li>
<li>offsetParent ：读取这个属性会触发回流。</li>
</ul>
</li>
<li>添加或者删除可见的 DOM 元素</li>
</ul>
<h5 id="ii、重绘触发条件"><a href="#ii、重绘触发条件" class="headerlink" title="ii、重绘触发条件"></a>ii、重绘触发条件</h5><blockquote>
<p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。</p>
</blockquote>
<p>下面这些操作会导致重绘：</p>
<ul>
<li>修改元素的颜色、背景色、文本颜色等可见样式。<ul>
<li>color、background 相关属性：background-color、background-image 等</li>
<li>outline 相关属性：outline-color、outline-width 、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
</li>
<li>切换 CSS 类名</li>
<li>使用 CSS 伪类（:hover、:active）等</li>
</ul>
<h5 id="iii、减少回流与重绘的措施"><a href="#iii、减少回流与重绘的措施" class="headerlink" title="iii、减少回流与重绘的措施"></a>iii、减少回流与重绘的措施</h5><ul>
<li>操作 DOM 时，尽量在低层级的 DOM 节点进行操作</li>
<li>不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新布局</li>
<li>使用 CSS 的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以将样式修改集中在一次操作中，使用 CSS 类名的切换来批量修改样式。</li>
<li>使用 CSS3 的 transform 属性来进行位移、缩放和旋转，它不会引起回流。</li>
<li>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>使用 requestAnimationFrame 方法来进行动画的更新，它能够优化性能并避免不必要的回流和重绘。</li>
<li>避免频繁操作 DOM，可以创建一个文档片段 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li>
<li>将元素先设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li>
<li>将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。<br>(浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。)</li>
</ul>
<h5 id="iv、CSS-的-transform-属性不会造成回流的原因"><a href="#iv、CSS-的-transform-属性不会造成回流的原因" class="headerlink" title="iv、CSS 的 transform 属性不会造成回流的原因"></a>iv、CSS 的 transform 属性不会造成回流的原因</h5><p>CSS 的 transform 属性不会造成回流的主要原因是，它对元素进行了一种视觉上的变换，而不影响元素在布局上的位置和大小。具体原因如下：</p>
<ul>
<li>硬件加速：当应用 transform 属性时，浏览器会将该元素视为一个单独的图层，并通过硬件加速来处理该图层的变换操作。因为硬件加速是在图层级别进行的，不影响其他元素的布局，所以不会触发回流。</li>
<li>独立图层：在某些情况下，浏览器会自动将某些元素创建为独立的图层，例如使用 3D 变换、透明度动画、嵌套的 CSS 动画等。这些独立的图层也能够享受硬件加速的好处，不会引起回流。</li>
<li>位置不变：transform 属性的变换并不改变元素在文档流中的位置，元素的原始位置仍然被保留。因此，当元素应用 transform 变换时，并不需要改变布局来适应变换后的状态。</li>
</ul>
<h2 id="2、优化动画"><a href="#2、优化动画" class="headerlink" title="2、优化动画"></a>2、优化动画</h2><ul>
<li>一般情况下，动画需要频繁的操作 DOM，就就会导致页面的性能问题，我们可以将动画的 position 属性设置为 absolute 或者 fixed，将动画脱离文档流，这样他的回流就不会影响到页面了。</li>
<li>使用 requestAnimationFrame 方法来进行动画的更新，它能够优化性能并避免不必要的回流和重绘。</li>
</ul>
<h2 id="3、使用-documentFragment-节点插入文档树"><a href="#3、使用-documentFragment-节点插入文档树" class="headerlink" title="3、使用 documentFragment 节点插入文档树"></a>3、使用 documentFragment 节点插入文档树</h2><p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的 DOM 操作时，我们就可以将 DOM 元素插入 DocumentFragment，之后一次性的将所有的子孙节点插入文档中。</p>
<p>和直接操作 DOM 相比，将 DocumentFragment 节点插入 DOM 树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p>
<h2 id="4、使用节流与防抖"><a href="#4、使用节流与防抖" class="headerlink" title="4、使用节流与防抖"></a>4、使用节流与防抖</h2><h5 id="i、函数节流的适用场景及代码实现"><a href="#i、函数节流的适用场景及代码实现" class="headerlink" title="i、函数节流的适用场景及代码实现"></a>i、函数节流的适用场景及代码实现</h5><blockquote>
<p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
</blockquote>
<p>函数节流的适⽤场景：</p>
<ul>
<li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</li>
<li>缩放场景：监控浏览器 resize</li>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
</ul>
<p>函数节流的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>],<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fun, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>    <span class="hljs-keyword">if</span> (!timeout) &#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun.<span class="hljs-title function_">apply</span>(context, args);<br>        timeout = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="ii、函数防抖的适用场景及代码实现"><a href="#ii、函数防抖的适用场景及代码实现" class="headerlink" title="ii、函数防抖的适用场景及代码实现"></a>ii、函数防抖的适用场景及代码实现</h5><blockquote>
<p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
</blockquote>
<p>函数防抖的适⽤场景：</p>
<ul>
<li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</li>
<li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤ lodash.debounce</li>
</ul>
<p>函数防抖的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>];<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5、图片优化"><a href="#5、图片优化" class="headerlink" title="5、图片优化"></a>5、图片优化</h2><ul>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。<br>一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。(或者使用阿里云 oss 等 api 对图片进行压缩、剪裁、质量变化能等)</li>
<li>小图使用 base64 格式（可配合 webpack）</li>
<li>将多个图标文件整合到一张图片中（雪碧图，可配合 webpack）</li>
<li>选择正确的图片格式：<ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</li>
</ul>
<h2 id="6、懒加载"><a href="#6、懒加载" class="headerlink" title="6、懒加载"></a>6、懒加载</h2><h5 id="i、图片懒加载"><a href="#i、图片懒加载" class="headerlink" title="i、图片懒加载"></a>i、图片懒加载</h5><p>有五种方式可实现图片懒加载：</p>
<ul>
<li><p>将 img 的 loading 属性设为“lazy”</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;deathghost.jpg&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;新码笔记&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>loading 属性选项如下：</p>
<ul>
<li>eager 默认，图像立即加载。</li>
<li>lazy 图像延迟加载，只有鼠标滚动到该图片所在位置才会显示。</li>
</ul>
</li>
<li><p>offsetTop - scrollTop &lt; &#x3D; innerHeight</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;img&quot;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> scrollTop =</span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> winHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; imgs.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-property">offsetTop</span> &lt; scrollTop + winHeight) &#123;</span><br><span class="language-javascript">        imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;data-src&quot;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyLoad</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>getBoundingClientRect</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) &#123;</span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> &#123;</span><br><span class="language-javascript">     top,</span><br><span class="language-javascript">     right,</span><br><span class="language-javascript">     bottom,</span><br><span class="language-javascript">     left,</span><br><span class="language-javascript">    &#125; = element.<span class="hljs-title function_">getBoundingClientRect</span>();</span><br><span class="language-javascript">  ​</span><br><span class="language-javascript">   <span class="hljs-keyword">return</span> (</span><br><span class="language-javascript">     top &gt;= <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="language-javascript">     left &gt;= <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="language-javascript">     right &lt;= viewWidth &amp;&amp;</span><br><span class="language-javascript">     bottom &lt;= viewHeight</span><br><span class="language-javascript">    );</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> winHeight= <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i &lt; imgs.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isInViewPort</span>(imgs[i]))&#123;</span><br><span class="language-javascript">        imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyLoad</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Intersection Observer</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> options = &#123;</span><br><span class="language-javascript">   <span class="hljs-comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="language-javascript">   <span class="hljs-comment">// 1 表示完全被包含</span></span><br><span class="language-javascript">   <span class="hljs-attr">threshold</span>: <span class="hljs-number">1.0</span>,</span><br><span class="language-javascript">   <span class="hljs-attr">root</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container&#x27;</span>) <span class="hljs-comment">// 必须是目标元素的父级元素</span></span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  ​</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">entries, observer</span>) =&gt; &#123;</span><br><span class="language-javascript">    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      entry.<span class="hljs-property">target</span>.<span class="hljs-property">src</span> = entry.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  ​</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, options);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  observer.<span class="hljs-title function_">observe</span>(target);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>vue-lazyload</p>
<p>在 vue2 中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js 文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueLazyload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-lazyload&quot;</span>;<br><span class="hljs-comment">// Vue.use(VueLazyload) //无配置项</span><br><span class="hljs-comment">// 配置项</span><br><span class="hljs-keyword">const</span> loadimage = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;assets/img/common/loading.gif&quot;</span>);<br><span class="hljs-comment">// const errorimage = require(&#x27;assets/img/common/error.gif&#x27;)</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>, &#123;<br>  <span class="hljs-attr">preLoad</span>: <span class="hljs-number">1.3</span>, <span class="hljs-comment">//预加载的宽高比</span><br>  <span class="hljs-attr">loading</span>: loadimage, <span class="hljs-comment">//图片加载状态下显示的图片 // error: errorimage, //图片加载失败时显示的图片</span><br>  <span class="hljs-attr">attempt</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 加载错误后最大尝试次数</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- vue模板使用v-lazy --&gt;<br>&lt;template&gt;<br>  &lt;ul&gt;<br>         <br>    &lt;li v-for=&quot;img in list&quot;&gt;<br>             &lt;img v-lazy=&quot;img.src&quot; :key=&quot;img.src&quot; /&gt;    <br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>在 vue3 中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> lazyPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue3-lazy&#x27;</span><br>​<br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>  .<span class="hljs-title function_">use</span>(lazyPlugin, &#123;<br>   <span class="hljs-attr">loading</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/assets/images/default.png&#x27;</span>), <span class="hljs-comment">// 图片加载时默认图片</span><br>   <span class="hljs-attr">error</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/assets/images/error.png&#x27;</span>)<span class="hljs-comment">// 图片加载失败时默认图片</span><br>  &#125;)<br>  .<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- vue模板使用v-lazy --&gt;<br>&lt;template&gt;<br>  &lt;ul&gt;<br>     <br>    &lt;li v-for=&quot;img in list&quot;&gt;   &lt;img v-lazy=&quot;img.src&quot; /&gt;  &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="ii、js-资源懒加载"><a href="#ii、js-资源懒加载" class="headerlink" title="ii、js 资源懒加载"></a>ii、js 资源懒加载</h5><p>在项目中，有一些场景需要用到比较重的库（比如 ECharts），但其使用频率和使用范围很小，只会在某个页面才会使用，这时候，可以考虑对其进行懒加载。</p>
<ul>
<li><p>对于一个基于 webpack 打包的项目，可通过 import 方法按需加载某个 js 资源，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// add.js（模拟某个js库）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// PageA路由页面</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PageA</span> () &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;./add.js&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-title function_">fn</span>(count, <span class="hljs-number">2</span>));<br>    &#125;);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> &lt;<span class="hljs-regexp">/div&gt;&#123;count&#125;&lt;/</span>div&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对于一个不是基于 webpack 打包的项目，可通过动态创建 <code>script</code> 标签以实现按需加载某个 js 资源，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadJS</span>(<span class="hljs-params">url: string, data?: <span class="hljs-built_in">Object</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>    s.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;src&quot;</span>, url);<br>    <span class="hljs-keyword">if</span> (data) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;<br>        s.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">`data-<span class="hljs-subst">$&#123;key&#125;</span>`</span>, data[key]);<br>      &#125;);<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(s);<br>    s.<span class="hljs-property">onload</span> = resolve;<br>    s.<span class="hljs-property">onerror</span> = reject;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> echartsScript = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;script[data-id=&quot;echarts&quot;]&#x27;</span>);<br><br><span class="hljs-comment">// 如果不存在echart库，则去按需加载</span><br><span class="hljs-keyword">if</span> (echartsScript === <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-title function_">loadJS</span>(<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js&quot;</span>, &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;echarts&quot;</span>,<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;echarts&quot;</span>, echarts);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、网络相关优化"><a href="#二、网络相关优化" class="headerlink" title="二、网络相关优化"></a>二、网络相关优化</h1><h2 id="1、使用-CDN"><a href="#1、使用-CDN" class="headerlink" title="1、使用 CDN"></a>1、使用 CDN</h2><h5 id="i、CDN-的原理"><a href="#i、CDN-的原理" class="headerlink" title="i、CDN 的原理"></a>i、CDN 的原理</h5><p>DNS 的解析域名过程，在浏览器输入 <a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> 的解析过程如下：</p>
<ol>
<li>检查浏览器缓存</li>
<li>检查操作系统缓存，常见的如 hosts 文件</li>
<li>检查路由器缓存</li>
<li>如果前几步都没没找到，会向 ISP(网络服务提供商)的 LDNS 服务器查询</li>
<li>如果 LDNS 服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</li>
</ol>
<ul>
<li>根服务器返回顶级域名(TLD)服务器如.com，.cn，.org 等的地址，该例子中会返回.com 的地址</li>
<li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.test 的地址</li>
<li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标 IP，本例子会返回<a target="_blank" rel="noopener" href="http://www.test.com的地址/">www.test.com的地址</a></li>
<li>Local DNS Server 会缓存结果，并返回给用户，缓存在系统中</li>
</ul>
<p>CDN 的工作原理：</p>
<ul>
<li>用户未使用 CDN 缓存资源的过程：<ol>
<li>浏览器通过 DNS 对域名进行解析（就是上面的 DNS 解析过程），依次得到此域名对应的 IP 地址</li>
<li>浏览器根据得到的 IP 地址，向域名的服务主机发送数据请求</li>
<li>服务器向浏览器返回响应数据</li>
</ol>
</li>
<li>用户使用 CDN 缓存资源的过程：<ol>
<li>对于点击的数据的 URL，经过本地 DNS 系统的解析，发现该 URL 对应的是一个 CDN 专用的 DNS 服务器，DNS 系统就会将域名解析权交给 CNAME 指向的 CDN 专用的 DNS 服务器。</li>
<li>CND 专用 DNS 服务器将 CND 的全局负载均衡设备 IP 地址返回给用户</li>
<li>用户向 CDN 的全局负载均衡设备发起数据请求</li>
<li>CDN 的全局负载均衡设备根据用户的 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li>
<li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的 IP 地址返回给全局负载均衡设备</li>
<li>全局负载均衡设备把服务器的 IP 地址返回给用户</li>
<li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li>
<li>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</li>
</ol>
</li>
</ul>
<h5 id="ii、CDN-的使用场景"><a href="#ii、CDN-的使用场景" class="headerlink" title="ii、CDN 的使用场景"></a>ii、CDN 的使用场景</h5><ul>
<li><strong>使用第三方的 CDN 服务：</strong>如果想要开源一些项目，可以使用第三方的 CDN 服务</li>
<li><strong>使用 CDN 进行静态资源的缓存：</strong>将自己网站的静态资源放在 CDN 上，比如 js、css、图片等。可以将整个项目放在 CDN 上，完成一键部署。</li>
<li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN 也是支持流媒体传送的，所以直播完全可以使用 CDN 来提高访问速度。CDN 在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li>
</ul>
<h2 id="2、使用缓存机制"><a href="#2、使用缓存机制" class="headerlink" title="2、使用缓存机制"></a>2、使用缓存机制</h2><h5 id="i、强缓存"><a href="#i、强缓存" class="headerlink" title="i、强缓存"></a>i、强缓存</h5><p>强缓存是指客户端直接使用本地缓存的资源，而无需向服务器发送请求。主要通过以下两种方式实现：</p>
<ol>
<li>Cache-Control：在服务器的响应头部中，设置 Cache-Control 指令来控制资源的缓存机制。常用的指令包括：</li>
</ol>
<ul>
<li>public：表示资源可以被任何缓存（包括客户端和代理服务器）缓存。</li>
<li>private：表示资源只能被客户端缓存，不可被代理服务器缓存。</li>
<li>max-age：指定资源的有效时间，单位为秒。客户端在该时间内可以直接使用本地缓存而无需发送请求。</li>
</ul>
<ol start="2">
<li>Expires：在服务器的响应头部中，设置 Expires 字段来指定资源的过期时间。它是一个具体的时间点，表示在该时间点之后，客户端不能再使用本地缓存，而是需要向服务器发送请求。</li>
</ol>
<h5 id="ii、协商缓存"><a href="#ii、协商缓存" class="headerlink" title="ii、协商缓存"></a>ii、协商缓存</h5><p>协商缓存是指客户端先向服务器发送请求，服务器通过对请求的验证来判断是否返回资源的实际内容。主要通过以下两种方式实现：</p>
<ol>
<li>ETag：在服务器的响应头部中，设置 ETag 字段来标识资源的版本号。客户端可以在后续请求中使用 If-None-Match 头部字段将上次响应中的 ETag 值发送给服务器，服务器通过比较资源的 ETag 值判断资源是否发生了变化，如果未发生变化，则返回 304 状态码，告知客户端可以使用缓存的资源。</li>
<li>Last-Modified：在服务器的响应头部中，设置 Last-Modified 字段来表示资源的最后修改时间。客户端可以在后续请求中使用 If-Modified-Since 头部字段将上次响应中的 Last-Modified 时间发送给服务器，服务器通过比较资源的最后修改时间判断资源是否发生了变化，如果未发生变化，则返回 304 状态码，告知客户端可以使用缓存的资源。</li>
</ol>
<h5 id="iii、强缓存和协商缓存结合使用"><a href="#iii、强缓存和协商缓存结合使用" class="headerlink" title="iii、强缓存和协商缓存结合使用"></a>iii、强缓存和协商缓存结合使用</h5><p>需要注意的是，强缓存是由客户端自身决定是否使用缓存，而协商缓存是由服务器来决定是否返回实际内容。通常情况下，当资源处于强缓存的有效期内时，客户端直接使用本地缓存的资源，不会发送请求到服务器；而当资源过期或存在其他的缓存验证字段时，客户端会发送请求到服务器并进行缓存的验证。两种缓存机制可以结合使用，实现更灵活和高效的缓存策略。</p>
<h5 id="iv、缓存中需要注意的细节点"><a href="#iv、缓存中需要注意的细节点" class="headerlink" title="iv、缓存中需要注意的细节点"></a>iv、缓存中需要注意的细节点</h5><ul>
<li><p>直接在浏览器端输入的 <a target="_blank" rel="noopener" href="http://xxx.xxx.com/index.html">http://xxx.xxx.com/index.html</a> ，该文件是不会被缓存的。</p>
</li>
<li><p>webpack 中的 hash 指纹，需要合理的利用，去让“该缓存的内容被缓存”。<br>不经常更新的文件改用 contentHash，例如：公共的样式文件，工具类 js 文件。</p>
</li>
<li><p>协商缓存中的 Modified 是根据时间判断，精确到秒，一秒时间内可能引发很多问题。</p>
<ul>
<li>如果同时有多个资源在同一秒内发生了修改，服务器可能无法准确识别出每个资源的变化，导致缓存失效。</li>
<li>如果服务器的时间与浏览器的时间存在偏差，可能导致资源的修改时间在服务器和浏览器之间不一致，进而造成缓存验证不准确。</li>
</ul>
<p>为了避免以上问题，通常建议在修改资源的同时，将”Last-Modified”时间向上取整到秒级，以增加时间的准确性。此外，还可以使用更精确的缓存验证机制，如 ETag，来解决精度不足的问题，以确保资源的缓存验证更为准确和可靠。</p>
</li>
<li><p>在 CDN 下，哈希缓存具有非常好的缓存效果。</p>
<p>哈希缓存是指在文件名中添加一个唯一的哈希值，当文件内容发生改变时，哈希值也会改变。CDN 会根据文件名来缓存和分发资源，因此当哈希值改变时，CDN 会将最新的文件缓存并提供给用户。</p>
<p>哈希缓存在 CDN 下可以实现以下优点：</p>
<ul>
<li>强制缓存更新：哈希缓存可以强制浏览器或 CDN 节点在文件内容发生变化时获取最新的资源。由于哈希值的改变，文件名也会改变，这会触发浏览器或 CDN 节点重新请求该资源，确保用户获得最新的版本。</li>
<li>缓解缓存一致性问题：在 CDN 集群中，缓存一致性是一个重要的问题。使用哈希缓存可以避免不同 CDN 节点之间的缓存不一致性问题。当-文件内容发生变化时，哈希值改变，文件名也改变，这样 CDN 将不再提供旧版本的资源，而是提供最新的版本。</li>
<li>消除浏览器缓存问题：浏览器缓存也是需要考虑的因素。通过哈希缓存，浏览器会将每个版本的资源看作是一个新的文件，并缓存该版本。这避免了浏览器在引用更新资源时使用旧版本的缓存。</li>
</ul>
<p>总结起来，哈希缓存在 CDN 下具有非常好的缓存效果。通过强制缓存更新、解决缓存一致性问题和消除浏览器缓存问题，哈希缓存可以确保用户获取到最新的资源版本，提高缓存命中率并加快内容传输速度，从而提升用户的访问体验。</p>
</li>
<li><p>没有了强缓存的必要字段值，浏览器还会走强缓存吗</p>
<ul>
<li>强缓存有效期由 Expires 和 Cache-Control 中的 max-age 来决定的，那么如果响应头中不存在这两个字段，缓存的有效期怎么计算呢？浏览器还会走强缓存吗？答案是肯定的，这就是我们要现在要了解的 启发式缓存。</li>
<li>当报头中没有用来确定强缓存时间的字段时，浏览器会触发启发式缓存，缓存有效期计算公式：<code>(date - last-modified) \* 10%</code>，取响应报头中 date 与 last-modified 值之差的百分之十作为缓存时间。启发式缓存比较容易忽略，不了解启发式缓存可能会因为这种默认的缓存方式而掉入坑里，但一旦你了解了浏览器启发式缓存的机制，很多问题都可以得到解决。</li>
</ul>
</li>
</ul>
<h2 id="3、使用-HTTP-版本特性"><a href="#3、使用-HTTP-版本特性" class="headerlink" title="3、使用 HTTP 版本特性"></a>3、使用 HTTP 版本特性</h2><h5 id="i、HTTP-各版本特性"><a href="#i、HTTP-各版本特性" class="headerlink" title="i、HTTP 各版本特性"></a>i、HTTP 各版本特性</h5><ol>
<li>HTTP&#x2F;1.0：</li>
</ol>
<ul>
<li>请求-响应模型：每个请求只能获得一个响应。</li>
<li>无状态：每个请求都是相互独立的，服务器不会保留之前的请求信息。</li>
<li>每个请求建立新的连接：每个请求都需要在客户端和服务器之间建立一个新的 TCP 连接。</li>
<li>无持久连接：每个请求的响应结束后，连接会被关闭。</li>
<li>每个资源一个请求：每个页面元素（如图片、样式表、脚本等）都需要单独的 HTTP 请求。</li>
</ul>
<ol start="2">
<li>HTTP&#x2F;1.1：</li>
</ol>
<ul>
<li>持久连接：多个请求可以在同一个连接上进行，提高效率。</li>
<li>管道化（Pipeline）：允许在一个连接上同时发送多个请求，减少延迟。</li>
<li>Host 头部字段：允许在同一台服务器上提供多个域名的不同网站。</li>
<li>增加了缓存机制：引入了更多的缓存控制头部字段，可以更好地利用缓存。</li>
<li>引入了分块传输编码（Chunked Transfer Encoding）：允许服务器逐块发送响应，有利于大文件的传输。</li>
</ul>
<ol start="3">
<li>HTTP&#x2F;2：</li>
</ol>
<ul>
<li>多路复用（Multiplexing）：多个请求可以在同一个连接上同时进行，提高性能。</li>
<li>二进制传输：HTTP&#x2F;2 使用二进制格式传输数据，替代了 HTTP&#x2F;1.x 的文本格式，提高了效率和解析速度。</li>
<li>头部压缩：使用 HPACK 算法对报文头部进行压缩，减少了数据传输量。</li>
<li>服务器推送（Server Push）：服务器可以主动推送资源给客户端，减少了客户端的请求次数。</li>
</ul>
<ol start="4">
<li>HTTP&#x2F;3：</li>
</ol>
<ul>
<li>基于 QUIC 协议：HTTP&#x2F;3 基于 QUIC（Quick UDP Internet Connections）协议，使用 UDP 替代 TCP，提供更低的延迟和更好的性能。</li>
<li>支持多路复用和头部压缩：HTTP&#x2F;3 也继承了 HTTP&#x2F;2 的多路复用和头部压缩特性。</li>
</ul>
<p>每个版本都试图改进性能、安全性和效率，以提供更好的 Web 体验。选择使用哪个版本取决于服务器和客户端的支持情况以及具体的需求。</p>
<h5 id="ii、使用-Keep-Alive"><a href="#ii、使用-Keep-Alive" class="headerlink" title="ii、使用 Keep-Alive"></a>ii、使用 Keep-Alive</h5><blockquote>
<p>Keep-Alive 是一种持久连接机制，旨在改善 HTTP 协议的性能表现。在传统的 HTTP&#x2F;1.0 中，每个客户端请求都需要与服务器建立一个新的 TCP 连接，这样会导致每个请求都要经历 TCP 连接的建立和释放的过程，增加了延迟和资源消耗。而使用 Keep-Alive，可以重复使用已经建立的 TCP 连接，减少了连接的建立和关闭过程。</p>
</blockquote>
<p>Keep-Alive 通过以下方式实现：</p>
<ol>
<li>持久连接：在 HTTP 头部中添加 Connection: keep-alive，表示客户端希望与服务器端保持持久连接。当服务器端收到这个头部后，会在响应中回复相同的头部，表示同意持久连接。</li>
<li>复用连接：客户端发送请求后，在服务器端响应结束后，TCP 连接并不会立即关闭，而是保持打开状态，以便进行下一个请求。</li>
<li>设置超时时间：连接在一段时间内没有新的请求时会自动关闭。</li>
</ol>
<p>使用 Keep-Alive 可以带来以下优点：</p>
<ul>
<li>减少延迟：避免了 TCP 连接的建立和关闭过程，因此减少了连接的延迟。</li>
<li>减少资源消耗：连接的复用减少了服务器端的负担，并且降低了网络带宽的占用。</li>
<li>提升性能：在一个连接上可以发送多个请求，实现并行请求，减少了网络拥塞和串行请求的影响。</li>
</ul>
<h2 id="4、权衡-TCP-请求数量"><a href="#4、权衡-TCP-请求数量" class="headerlink" title="4、权衡 TCP 请求数量"></a>4、权衡 TCP 请求数量</h2><p>如何在 TCP 请求数量之间权衡？</p>
<ul>
<li>Chrome 同源下最多 6 个并发</li>
<li>在 TCP 请求数量之间存在一个权衡（tradeoff）。增加 TCP 请求的数量可以提高并发性和响应速度，但也会增加网络开销和资源消耗。反之，减少 TCP 请求的数量可以节省网络资源和降低开销，但可能会牺牲一定的并发性和响应速度。</li>
</ul>
<p>权衡的建议：</p>
<ul>
<li>批量请求：对于需要发送多个相似请求的情况，可以将其批量处理为一个更少的请求。例如，可以使用合适的数据格式（如 JSON）将多个数据项一次性发送给服务器，从而减少请求的数量。</li>
<li>长连接和连接池：通过使用长连接和连接池，可以避免频繁建立和断开 TCP 连接的开销。长连接可以在多个请求之间保持连接状态，而连接池可以重用现有连接，从而减少连接建立和拆除的开销。</li>
<li>并发限制和调整：可以根据网络和服务器的容量限制并发请求数量。过多的并发请求可能会导致网络拥塞和服务器负载过重，从而影响性能。因此，需要找到一个合适的并发请求数量，既能满足需求，又不会过度压力网络和服务器。</li>
<li>缓存和本地存储：利用缓存和本地存储减少对服务器的请求。缓存可以在客户端保留数据的副本，以便在需要时快速访问。本地存储（如浏览器的 localStorage）可以将数据存储在客户端，避免不必要的请求，提高响应速度。</li>
<li>延迟加载和懒加载：对于大型应用或页面，可以延迟加载或懒加载一些资源，以减少初始请求的数量。只加载当前所需的资源，而不是一次性加载所有资源，可以提高初始加载速度，并根据需要动态加载其他资源。</li>
</ul>
<h2 id="5、开启-gzip-压缩"><a href="#5、开启-gzip-压缩" class="headerlink" title="5、开启 gzip 压缩"></a>5、开启 gzip 压缩</h2><p>服务器端开启 gzip 压缩，可通过配置 nginx 或 node 服务实现。</p>
<ol>
<li>nginx 开启 gzip 压缩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">http &#123;<br>  gzip  on;<br>  gzip_types  text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>node 服务开始 gzip 压缩</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> compression = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;compression&quot;</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">compression</span>());<br></code></pre></td></tr></table></figure>

<h2 id="6、对脚本的优化"><a href="#6、对脚本的优化" class="headerlink" title="6、对脚本的优化"></a>6、对脚本的优化</h2><ul>
<li><p>一般情况要将样式文件放在 head 内，因为样式文件一旦加载好就会立即渲染已经构建好的节点元素，如果样式文件放在 body 标签中间引入很容易造成回流&#x2F;重排。</p>
</li>
<li><p>将脚本放在 <head> 中可能会导致页面加载阻塞，因为脚本的下载和执行会阻塞页面的渲染。如果脚本较大或执行时间较长，页面加载速度可能会受到影响。</p>
</li>
<li><p>放在 <body> 元素底部：为了避免阻塞页面加载，可以将 script 标签放在 <body> 元素的底部，即在页面内容后面。这样，在页面内容加载完成后再加载和执行脚本，不会阻塞页面的初始渲染。</p>
</li>
<li><p>除了上述两种常见的放置位置外，还可以使用异步加载和延迟加载来优化脚本加载行为。这些技术可以通过 async 和 defer 属性来实现，允许脚本的异步或延迟加载，以优化页面加载性能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">默认模式：<br>                download-execute<br>------parse------                ------parse------<br><br>defer 模式（推迟执行模式）：<br>                download                 execute<br>------parse--------------------parse------<br><br><span class="hljs-keyword">async</span> 模式（异步下载模式）：<br>                download-execute<br>------parse---------------       ------parse------<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、React-相关优化"><a href="#三、React-相关优化" class="headerlink" title="三、React 相关优化"></a>三、React 相关优化</h1><h2 id="1、避免不必要的组件更新"><a href="#1、避免不必要的组件更新" class="headerlink" title="1、避免不必要的组件更新"></a>1、避免不必要的组件更新</h2><p>我们知道 React 不像 Vue 对 state 做了细颗粒度控制，对各 state 都进行了依赖收集，并再根据时机去按需触发对应节点的渲染。React 父组件只要有 state 改变，就会触发本组件及子组件的重新渲染，不管该 state 是否对子节点或子组件有影响，这是 React 的渲染机制决定。</p>
<p>而触发 React 组件的 Render 过程目前有三种方式，分别为 forceUpdate、State 更新、父组件 Render 触发子组件 Render 过程。那么，有什么手段可以尽量减少或避免组件的更新，从而提高渲染性能呢？</p>
<h5 id="i、状态下放，缩小状态影响范围"><a href="#i、状态下放，缩小状态影响范围" class="headerlink" title="i、状态下放，缩小状态影响范围"></a>i、状态下放，缩小状态影响范围</h5><ul>
<li><p>场景一：一个状态只在部分子树中使用</p>
<p>如下示例，优化前：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveComp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件ExpensiveComp渲染&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    I am a expensive component.</span><br><span class="language-xml">    &#123;</span><br><span class="language-xml">      new Array(100).fill(0).map((item, index) =&gt; &#123;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> &gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#125;)</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> inputChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- count在input中使用 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- count在p中使用 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123; count &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComp</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveComp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件ExpensiveComp渲染&quot;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      I am a expensive component.</span><br><span class="language-xml">      &#123;new Array(100).fill(0).map((item, index) =&gt; &#123;</span><br><span class="language-xml">        return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml">      &#125;)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">InputCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> inputChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">InputCount</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComp</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>场景二：一个状态在顶级和部分子树中都使用</p>
<p>如下示例，优化前：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveComp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件ExpensiveComp渲染&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    I am a expensive component.</span><br><span class="language-xml">    &#123;</span><br><span class="language-xml">      new Array(100).fill(0).map((item, index) =&gt; &#123;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> &gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#125;)</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> inputChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;!-- count在根节点div中使用 --&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dataCount</span>=<span class="hljs-string">&#123;count&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- count在input中使用 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- count在input中使用 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123; count &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComp</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveComp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件ExpensiveComp渲染&quot;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      I am a expensive component.</span><br><span class="language-xml">      &#123;new Array(100).fill(0).map((item, index) =&gt; &#123;</span><br><span class="language-xml">        return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;</span><br><span class="language-xml">      &#125;)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CountContainer</span>(<span class="hljs-params">&#123; ExpensiveComp &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> inputChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dataCount</span>=<span class="hljs-string">&#123;count&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      &#123;ExpensiveComp&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountContainer</span> <span class="hljs-attr">ExpensiveComp</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">ExpensiveComp</span> /&gt;</span>&#125; /&gt;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="ii、PureComponent-和-React-memo"><a href="#ii、PureComponent-和-React-memo" class="headerlink" title="ii、PureComponent 和 React.memo"></a>ii、PureComponent 和 React.memo</h5><p>我们开发过程中，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变。而 PureComponent 和 React.memo 就是应对这种场景的，PureComponent 是对类组件的 Props 和 State 进行浅比较，React.memo 是对函数组件的 Props 进行浅比较。</p>
<p>React.memo 作为第一个高阶组件，第二个参数 可以对 props 进行比较 ，和 shouldComponentUpdate 不同的, 当第二个参数返回 true 的时候，证明 props 没有改变，不渲染组件，反之渲染组件。</p>
<h5 id="iii、shouldComponentUpdate"><a href="#iii、shouldComponentUpdate" class="headerlink" title="iii、shouldComponentUpdate"></a>iii、shouldComponentUpdate</h5><p>使用 shouldComponentUpdate() 以让 React 知道当 state 或 props 的改变是否影响组件的重新 render，默认返回 ture，返回 false 时不会重新渲染更新，而且该方法并不会在初始化渲染或当使用 forceUpdate() 时被调用。</p>
<h5 id="iv、immetable-js"><a href="#iv、immetable-js" class="headerlink" title="iv、immetable.js"></a>iv、immetable.js</h5><p>immetable.js 是 Facebook 开发的一个 js 库，可以提高对象的比较性能，像之前所说的 pureComponent 只能对对象进行浅比较，,对于对象的数据类型,却束手无策,所以我们可以用 immetable.js 配合 shouldComponentUpdate 或者 React.memo 来使用。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; is &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;immutable&quot;</span>;<br><br><span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<br>  <span class="hljs-function">(<span class="hljs-params">&#123; List &#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;List.map((item, index) =&gt; &#123;</span><br><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>;</span><br><span class="language-xml">        &#125;)&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">pre, next</span>) =&gt;</span> <span class="hljs-title function_">is</span>(pre.<span class="hljs-property">List</span>, next.<span class="hljs-property">List</span>)<br>);<br></code></pre></td></tr></table></figure>

<h5 id="v、使用-useMemo、useCallback-实现稳定的-Props-值"><a href="#v、使用-useMemo、useCallback-实现稳定的-Props-值" class="headerlink" title="v、使用 useMemo、useCallback 实现稳定的 Props 值"></a>v、使用 useMemo、useCallback 实现稳定的 Props 值</h5><p>如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。</p>
<ul>
<li><p>useCallback 的场景，如下示例，优化前：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; memo, useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">InputCount</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; onChange: onChangeProp &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">inputChangeHandle</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>    onChangeProp &amp;&amp; <span class="hljs-title function_">onChangeProp</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onChangeHandle</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">InputCount</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;onChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然 InputCount 组件使用 React.memo 优化过，对 Props 进行浅比较从而决定是否重新渲染，但是 App 组件每次点击按钮更改了 state <code>value</code>，从而 App 组件重新渲染，导致了<code>btnClickHandle</code>监听函数的引用值变化，最后导致被 React.memo 优化过的 InputCount 组件也会重新渲染。</p>
<p>这不是我们期望的，所以可以借助 useCallback 对监听函数进行缓存，这样它的引用值不再会变化。</p>
<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; memo, useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">InputCount</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; onChange: onChangeProp &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">inputChangeHandle</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>    onChangeProp &amp;&amp; <span class="hljs-title function_">onChangeProp</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;inputChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> onChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">InputCount</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;onChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>useMemo 同理，可对类型是对象或数组引用类型的 prop，可对其进行 useMemo 处理。</p>
<p>示例如下，优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; memo, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComp</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; valueArr &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> valueArr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value1, setValue1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value2, setValue2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value3, setValue3] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue1</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue2</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue3</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span> <span class="hljs-attr">valueArr</span>=<span class="hljs-string">&#123;[value1,</span> <span class="hljs-attr">value2</span>]&#125; /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle1&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle2&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle3&#125;</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当点击按钮 3，也会导致 ChildComp 组件重新渲染。</p>
<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; memo, useState, useMemo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComp</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; valueArr &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> valueArr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value1, setValue1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value2, setValue2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value3, setValue3] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue1</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue2</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue3</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> valueArr = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> [value1, value2];<br>  &#125;, [value1, value2]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span> <span class="hljs-attr">valueArr</span>=<span class="hljs-string">&#123;valueArr&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle1&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle2&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle3&#125;</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="vi、删除没必要的-useMemo-和-useCallback"><a href="#vi、删除没必要的-useMemo-和-useCallback" class="headerlink" title="vi、删除没必要的 useMemo 和 useCallback"></a>vi、删除没必要的 useMemo 和 useCallback</h5><p>上节<a href="#v%E4%BD%BF%E7%94%A8-usememousecallback-%E5%AE%9E%E7%8E%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-props-%E5%80%BC">使用 useMemo、useCallback 实现稳定的 Props 值</a>，为了不影响子组件<strong>ChildComp</strong>的重新渲染，对 prop 属性进行了 useMemo 处理或对监听函数进行了 useCallback 处理，这种处理是有必要的，因为<strong>ChildComp</strong>组件本身已被<strong>React.memo</strong>缓存。</p>
<p>然而，在我们平时的开发过程中，可能由于<strong>缓存 prop 以避免重新渲染子组件</strong>或<strong>避免开销巨大的计算</strong>的思想，经常无脑对 prop 属性或开销巨大的计算逻辑进行 useMemo 处理，或对监听函数进行 useCallback 处理，这样做有可能导致不仅最初的目的没达到，反而影响了父组件初始化渲染的性能，因为 useMemo 和 useCallback 也是消耗额外的内存的。</p>
<p>下面举些例子，都是没必要使用 useMemo 和 useCallback 的场景。</p>
<ul>
<li><p>场景一(缓存 props 以避免重渲染)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; memo, useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComp</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">&#123; valueArr &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> valueArr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [valueArr, setValueArr] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> onChangeHandle = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValueArr</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> [...val, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)]);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span> <span class="hljs-attr">valueArr</span>=<span class="hljs-string">&#123;valueArr&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;onChangeHandle&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该场景，对 onChangeHandle 函数进行了 useCallback 缓存处理，最初目的是为了避免 onChangeHandle 函数的改变，从而导致重复渲染<em>ChildComp</em>组件。但事实上，<em>valueArr</em>prop 属性是一个经常会改变的 state，随着每次点击按钮，valueArr 会自增一个元素，<em>ChildComp</em>组件将会重新渲染。</p>
<p>所以，该场景对 onChangeHandle 的缓存处理没太大意义，反而增加了 useCallback 对内存额外的消耗，导致初始化<em>App</em>父组件的时间延长。虽然延长的时间可以说微不足道，但是想想假如是一个很重的组件，那可能会导致<strong>没必要</strong>的渲染压力。</p>
<p>我们可以得出结论，只有在唯一的一种场景下，缓存 props 才是有意义的：<strong>当组件的每一个 prop，以及组件本身被缓存的时候</strong>。</p>
<p>如果组件代码里有以下情形，我们可以毫无心理负担地删掉 useMemo 和 useCallback：</p>
<ul>
<li>它们被作为 attributes ，直接地或作为依赖树的上层，被传递到某个 DOM 上</li>
<li>它们被作为 props，直接地或作为依赖树的上层，被传递到某个未被缓存的组件上</li>
<li>它们被作为 props，直接地或作为依赖树的上层，被传递到某个组件上，而那个组件至少有一个 prop 未被缓存</li>
</ul>
</li>
<li><p>场景二(在每次重渲染时避免开销巨大的运算)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params">&#123; countries &#125;</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 对国家list（250个）按名字进行排序，不使用useMemo</span><br>  <span class="hljs-keyword">const</span> sortedCountries = <span class="hljs-title function_">orderBy</span>(countries, <span class="hljs-string">&quot;name&quot;</span>);<br>  <span class="hljs-comment">// 使用useMemo</span><br>  <span class="hljs-comment">// const sortedCountries = useMemo(orderBy(countries, &#x27;name&#x27;, sort));</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;sortedCountries.map((country) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">country</span>=<span class="hljs-string">&#123;country&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;country.id&#125;</span> /&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一般开发过程中，我们遇见这样对数组操作计算的场景，会用 useMemo 包裹，防止每次渲染对其重新计算。但实事上，有必要这样做么？</p>
<p>我们可以尝试测试下耗时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params">&#123; countries &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> before = performance.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">const</span> sortedCountries = <span class="hljs-title function_">orderBy</span>(countries, <span class="hljs-string">&quot;name&quot;</span>);<br>  <span class="hljs-keyword">const</span> after = performance.<span class="hljs-title function_">now</span>() - before;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;耗时：&quot;</span>, after);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;sortedCountries.map((country) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">country</span>=<span class="hljs-string">&#123;country&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;country.id&#125;</span> /&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>测试可得，如果不使用 useMemo 缓存的话，给 250 元素的 list 排序，耗时<strong>少于 2 毫秒</strong>。作为比较，渲染这个列表——仅仅是原生的按钮上带文字——就消耗了 20 毫秒。</p>
<p>在实际场景中，数组往往比示例中的更小，同时渲染的内容比示例中的更复杂，因此更慢。所以总的来说「计算」与「渲染」之间的耗时往往超过 10 倍。</p>
<p>与其说缓存数组操作，我们更应该缓存的是实际上是最耗时的计算——重渲染并更新组件。像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params">&#123; countries &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> content = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> sortedCountries = <span class="hljs-title function_">orderBy</span>(countries, <span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-keyword">return</span> sortedCountries.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">country</span>) =&gt;</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">country</span>=<span class="hljs-string">&#123;country&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;country.id&#125;</span> /&gt;</span></span><br>    ));<br>  &#125;, [countries]);<br>  <span class="hljs-keyword">return</span> content;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>以上 useMemo 把大约 20ms 的重渲染时间，减少了不到 2ms。</p>
<p>所以，关于缓存”开销巨大“操作的一条准则就是：除非你真的要搞类似大数阶乘，疯狂递归这样的操作，否则就在纯 javascript 操作中把 useMemo 删掉吧。重渲染元素才是你的瓶颈，请只在渲染树的重要部分使用 useMemo。</p>
<p>那为啥一定要删掉它们呢？把所有东西缓存起来不是更好吗？哪怕只让重渲染速度提升了 2ms，这里提升 2ms，那里提升 2ms，累加起来就很可观了呀。换个角度看，如果完全不写 useMemo，那么应用就会在这里慢 2ms，在那里又慢 2ms，很快我们的应用就会比它们原本能达到的程度慢的多了。</p>
<p>但我们忽略的一点便是：缓存并不是毫无开销的。如果我们使用 useMemo，在初始渲染过程中 React 就需要缓存其值了——这当然也产生耗时。虽然耗时很微小，在上述的 demo 中，缓存上述提到过的排序国家列表耗时不超过 1ms。但是！这才会产生货真价实的叠加效应！在初始渲染让你的应用第一次呈现在屏幕前的过程中，当前页面的每一个元素都会经历这一过程，这将导致 10~20 ms，或更糟糕的，接近 100ms 的不必要的延时。</p>
<p>与初始渲染相比，重渲染仅仅在页面某些部分改变时发生。那么在一次寻常的重渲染中，<em>经过缓存计算处理过</em>的重渲染也仅仅是节省了 10ms 的渲染时间，这么短的时间间隔我们的肉眼是无法察觉的。可作为代价的是，它确实拖慢了每次都会发生的初始渲染过程。</p>
<p>总结：参与初始渲染的是整个页面相关的组件，参与重渲染的只是局部的组件，两者不是一个数量级。参与初始渲染的大量组件，被 useMemo 和 useCallbak  拖慢所产生的叠加明显，远远比参与重渲染的少量组件，被  useMemo 和 useCallbak 所优化所产生的叠加效应来的明显！也就是说，资不抵债，这笔优化划不来。</p>
</li>
</ul>
<p>总结如下：</p>
<ul>
<li>useCallback 和 useMemo 仅仅在后续渲染（也就是重渲染）中起作用，在初始渲染中它们反而是有害的</li>
<li>useCallback 和 useMemo 作用于 props 并不能避免组件重渲染。只有当每一个 prop 都被缓存，且组件本身也被缓存的情况下，重渲染才能被避免。只要有一丁点疏忽，那么你做的一切努力就打水漂了。所以说，简单点，把它们都删了吧。</li>
<li>把包裹了“纯 js 操作“的 useMemo 也都删了吧。与组件本身的渲染相比，它缓存数据带来的耗时减少是微不足道的，并且会在初始渲染时消耗额外的内存，造成可以被观察到的延迟。</li>
</ul>
<h5 id="vii、使用发布订阅模式跳过中间组件渲染"><a href="#vii、使用发布订阅模式跳过中间组件渲染" class="headerlink" title="vii、使用发布订阅模式跳过中间组件渲染"></a>vii、使用发布订阅模式跳过中间组件渲染</h5><p>React 推荐将公共数据放在所有<em>需要该状态的组件</em>的公共祖先上，但将状态放在公共祖先上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。</p>
<p>每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下可以将状态用发布订阅模式维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。</p>
<p>只要是发布订阅模式的库，都可以进行该优化。比如：redux、React.createContext 等。</p>
<h2 id="2、规范写法"><a href="#2、规范写法" class="headerlink" title="2、规范写法"></a>2、规范写法</h2><h5 id="i、绑定事件尽量不要使用箭头函数"><a href="#i、绑定事件尽量不要使用箭头函数" class="headerlink" title="i、绑定事件尽量不要使用箭头函数"></a>i、绑定事件尽量不要使用箭头函数</h5><p>上面示例也提到过，当每次渲染时，箭头函数绑定事件会创建一个新的事件处理器，从而改变了 prop 的引用值，这会导致子组件每次都会被渲染。</p>
<h5 id="ii、列表项正确使用-key-属性"><a href="#ii、列表项正确使用-key-属性" class="headerlink" title="ii、列表项正确使用 key 属性"></a>ii、列表项正确使用 key 属性</h5><p>用唯一 id 作为列表项的 key，不要用 index 做 key，或者用 index 拼接其他的字段。除非列表项数据是不变的情况，可考虑使用 index 作为 key。</p>
<h5 id="iii、函数组件避免变量的重复声明"><a href="#iii、函数组件避免变量的重复声明" class="headerlink" title="iii、函数组件避免变量的重复声明"></a>iii、函数组件避免变量的重复声明</h5><p>如下示例，优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value1, setValue1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value2, setValue2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value3, setValue3] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue1</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue2</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setValue3</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle1&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle2&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle3&#125;</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState, useMemo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value1, setValue1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value2, setValue2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> [value3, setValue3] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);<br><br>  <span class="hljs-keyword">const</span> [btnClickHandle1, btnClickHandle2, btnClickHandle3] = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setValue1</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setValue2</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">btnClickHandle3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-title function_">setValue3</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val + <span class="hljs-number">1</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> [btnClickHandle1, btnClickHandle2, btnClickHandle3];<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle1&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle2&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value3&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;btnClickHandle3&#125;</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="iv、避免在组件即将卸载的时候去更改-state"><a href="#iv、避免在组件即将卸载的时候去更改-state" class="headerlink" title="iv、避免在组件即将卸载的时候去更改 state"></a>iv、避免在组件即将卸载的时候去更改 state</h5><p>在 React 16.8 版本中，如果在<code>componentWillUnmount</code>或<code>useEffect(() =&gt; &#123; return () =&gt; &#123; /setState/ &#125; &#125;)</code>更改了 state，或调用 ant 组件 from 的 api<code>form.resetFields()</code>，则控台太会报错提示<em>Can’t perform a React state update on an unmounted component</em>。</p>
<p>这是因为 React17 之前的版本，官方为了解决在 useEffect 里忘记取消事件订阅而做的提示，用来防止开发者内存泄露:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setState</span>(store.<span class="hljs-title function_">getState</span>());<br>  &#125;<br>  store.<span class="hljs-title function_">subscribe</span>(handleChange);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">unsubscribe</span>(handleChange);<br>&#125;, []);<br></code></pre></td></tr></table></figure>

<p>而实际上，开发过程中，我们的场景经常是使用第三方库比如 react store，所以不存在上述问题。</p>
<p>但有一种情况，我们在开发过程中，经常在<code>componentDidMount</code>或<code>useEffect</code>中异步调用接口去请求数据后，再去 setState，如果当这个异步过程还没完成，就跳转别的路由页面，则会导致当前组件卸载，那就可能会导致上述的报错，虽然并不会造成内存泄露。</p>
<p>解决方法：</p>
<ol>
<li>定义一个变量标识是否已经 mounted，如果 mounted 再去 setState</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">true</span>;<br>  <span class="hljs-title function_">someAsyncOperation</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isMounted) <span class="hljs-title function_">setState</span>(data);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    isMounted = <span class="hljs-literal">false</span>;<br>  &#125;;<br>&#125;, []);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>上述方法仅仅为了解决报错，实际上此报错不会带来内存泄露，而且给打开人员带来了理解上的成本，最好就是 react 升级 17 版本以上，17 移除了这个死板的提示。</li>
</ol>
<h1 id="四、Vue-相关优化"><a href="#四、Vue-相关优化" class="headerlink" title="四、Vue 相关优化"></a>四、Vue 相关优化</h1><h2 id="1、使用函数式组件"><a href="#1、使用函数式组件" class="headerlink" title="1、使用函数式组件"></a>1、使用函数式组件</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cell&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template functional&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cell&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;props.value&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>函数式组件和普通的对象类型的组件不同，它不会被看作成一个真正的组件，我们知道在 patch 过程中，如果遇到一个节点是组件 vnode，会递归执行子组件的初始化过程；而函数式组件的 render 生成的是普通的 vnode，不会有递归子组件的过程，因此渲染开销会低很多。</p>
<p>因此，函数式组件也不会有状态，不会有响应式数据，生命周期钩子函数这些东西。你可以把它当成把普通组件模板中的一部分 DOM 剥离出来，通过函数的方式渲染出来，是一种在 DOM 层面的复用。</p>
<h2 id="2、子组件拆分"><a href="#2、子组件拆分" class="headerlink" title="2、子组件拆分"></a>2、子组件拆分</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; opacity: number / 300 &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; heavy() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;number&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    heavy () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> n = <span class="hljs-number">100000</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-number">42</span>)))</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> result</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; opacity: number / 300 &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">ChildComp</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        heavy () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> n = <span class="hljs-number">100000</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-number">42</span>)))</span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">return</span> result</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      render (h) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">heavy</span>())</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;number&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>示例通过一个 heavy 函数模拟了一个耗时的任务，且这个函数在每次渲染的时候都会执行一次，所以每次组件的渲染都会消耗较长的时间执行 JavaScript。</p>
<p>而优化后的方式是把这个耗时任务 heavy 函数的执行逻辑用子组件 ChildComp 封装了，由于 Vue 的更新是组件粒度的，虽然每一帧都通过数据修改导致了父组件的重新渲染，但是 ChildComp 却不会重新渲染，因为它的内部也没有任何响应式数据的变化。所以优化后的组件不会在每次渲染都执行耗时任务，自然执行的 JavaScript 时间就变少了。</p>
<h2 id="3、局部变量"><a href="#3、局部变量" class="headerlink" title="3、局部变量"></a>3、局部变量</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; opacity: start / 300 &#125;&quot;</span>&gt;</span>&#123;&#123; result &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;start&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    base () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-number">42</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    result () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span>))) + <span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span> * <span class="hljs-number">2</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">base</span> * <span class="hljs-number">3</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> result</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; opacity: start / 300 &#125;&quot;</span>&gt;</span>&#123;&#123; result &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;start&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    base () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-number">42</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    result (&#123; base, start &#125;) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> result = start</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(base))) + base * base + base + base * <span class="hljs-number">2</span> + base * <span class="hljs-number">3</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> result</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>优化前的组件多次在计算过程中访问 this.base，而优化后的组件会在计算前先用局部变量 base，缓存 this.base，后面直接访问 base。</p>
<p>优化前因为每次访问 this.base 的时候，由于 this.base 是一个响应式对象，所以会触发它的 getter，进而会执行依赖收集相关逻辑代码。类似的逻辑执行多了，像示例这样，几百次循环更新几百个组件，每个组件触发 computed 重新计算，然后又多次执行依赖收集相关逻辑，性能自然就下降了。</p>
<p>而优化后 this.base 执行一次依赖收集就够了，把它的 getter 求值结果返回给局部变量 base，后续再次访问 base 的时候就不会触发 getter，也不会走依赖收集的逻辑了，性能自然就得到了提升。</p>
<h2 id="4、使用-v-show-复用-DOM"><a href="#4、使用-v-show-复用-DOM" class="headerlink" title="4、使用 v-show 复用 DOM"></a>4、使用 v-show 复用 DOM</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template functional&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cell&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;props.value&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template functional&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cell&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;props.value&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!props.value&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>优化前后的主要区别是用 v-show 指令替代了 v-if 指令来替代组件的显隐，虽然从表现上看，v-show 和 v-if 类似，都是控制组件的显隐，但内部实现差距还是很大的。</p>
<p>对于 v-if 渲染的节点，由于新旧节点 vnode 不一致，在核心 diff 算法比对过程中，会移除旧的 vnode 节点，创建新的 vnode 节点，那么就会创建新的 Heavy 组件，又会经历 Heavy 组件自身初始化、渲染 vnode、patch 等过程。因此使用 v-if 每次更新组件都会创建新的 Heavy 子组件，当更新的组件多了，自然就会造成性能压力。</p>
<p>对于 v-show 渲染的节点，由于新旧 vnode 一致，它们只需要一直 patchVnode 即可，在 patchVnode 过程中，内部会对执行 v-show 指令对应的钩子函数 update，然后它会根据 v-show 指令绑定的值来设置它作用的 DOM 元素的 style.display 的值控制显隐。</p>
<p>因此相比于 v-if 不断删除和创建函数新的 DOM，v-show 仅仅是在更新现有 DOM 的显隐值，所以 v-show 的开销要比 v-if 小的多，当其内部 DOM 结构越复杂，性能的差异就会越大。</p>
<h2 id="5、使用-KeepAlive"><a href="#5、使用-KeepAlive" class="headerlink" title="5、使用 KeepAlive"></a>5、使用 KeepAlive</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>在非优化场景下，我们每次点击按钮切换路由视图，都会重新渲染一次组件，渲染组件就会经过组件初始化，render、patch 等过程，如果组件比较复杂，或者嵌套较深，那么整个渲染耗时就会很长。</p>
<p>而在使用 KeepAlive 后，被 KeepAlive 包裹的组件在经过第一次渲染后，的 vnode 以及 DOM 都会被缓存起来，然后再下一次再次渲染该组件的时候，直接从缓存中拿到对应的 vnode 和 DOM，然后渲染，并不需要再走一次组件初始化，render 和 patch 等一系列流程，减少了 script 的执行时间，性能更好。</p>
<p>但是使用 KeepAlive 组件并非没有成本，因为它会占用更多的内存去做缓存，这是一种典型的空间换时间优化思想的应用。</p>
<h2 id="6、使用-Deferred-组件延时分批渲染组件"><a href="#6、使用-Deferred-组件延时分批渲染组件" class="headerlink" title="6、使用 Deferred 组件延时分批渲染组件"></a>6、使用 Deferred 组件延时分批渲染组件</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deferred-off&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">VueIcon</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;fitness_center&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gigantic&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I&#x27;m an heavy page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 8&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;n&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;super-heavy&quot;</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;9999999&quot;</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mixins/Defer</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">count = <span class="hljs-number">10</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">displayPriority</span>: <span class="hljs-number">0</span>,<br>      &#125;;<br>    &#125;,<br><br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runDisplayPriority</span>();<br>    &#125;,<br><br>    <span class="hljs-attr">methods</span>: &#123;<br>      <span class="hljs-title function_">runDisplayPriority</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>          <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">displayPriority</span>++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">displayPriority</span> &lt; count) &#123;<br>              <span class="hljs-title function_">step</span>();<br>            &#125;<br>          &#125;);<br>        &#125;;<br>        <span class="hljs-title function_">step</span>();<br>      &#125;,<br><br>      <span class="hljs-title function_">defer</span>(<span class="hljs-params">priority</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">displayPriority</span> &gt;= priority;<br>      &#125;,<br>    &#125;,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deferred-on&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">VueIcon</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;fitness_center&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gigantic&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I&#x27;m an heavy page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;defer(2)&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 8&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;n&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Heavy</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;defer(3)&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;super-heavy&quot;</span> <span class="hljs-attr">:n</span>=<span class="hljs-string">&quot;9999999&quot;</span>/&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Defer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/mixins/Defer&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">mixins</span>: [</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Defer</span>(),</span></span><br><span class="language-javascript"><span class="language-xml">  ],</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>优化前后的差距主要是后者使用了 Defer 这个 mixin，Defer 的主要思想就是把一个组件的一次渲染拆成多次，它内部维护了 displayPriority 变量，然后在通过 requestAnimationFrame 在每一帧渲染的时候自增，最多加到 count。然后使用 Defer mixin 的组件内部就可以通过 v-if&#x3D;”defer(xxx)” 的方式来控制在 displayPriority 增加到 xxx 的时候渲染某些区块了。</p>
<p>当你有渲染耗时的组件，使用 Deferred 做渐进式渲染是不错的注意，它能避免一次 render 由于 JS 执行时间过长导致渲染卡住的现象。</p>
<h2 id="7、使用-Time-slicing-时间片切割技术"><a href="#7、使用-Time-slicing-时间片切割技术" class="headerlink" title="7、使用 Time slicing 时间片切割技术"></a>7、使用 Time slicing 时间片切割技术</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchItems (&#123; commit &#125;, &#123; items &#125;) &#123;<br>  <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearItems&#x27;</span>)<br>  <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;addItems&#x27;</span>, items)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchItems (&#123; commit &#125;, &#123; items, splitCount &#125;) &#123;<br>  <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearItems&#x27;</span>)<br>  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobQueue</span>()<br>  <span class="hljs-title function_">splitArray</span>(items, splitCount).<span class="hljs-title function_">forEach</span>(<br>    <span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> queue.<span class="hljs-title function_">addJob</span>(<span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 分时间片提交数据</span><br>      <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;addItems&#x27;</span>, chunk)<br>        <span class="hljs-title function_">done</span>()<br>      &#125;)<br>    &#125;)<br>  )<br>  <span class="hljs-keyword">await</span> queue.<span class="hljs-title function_">start</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化前点击提交按钮，页面会卡死 1.2 秒左右，在优化后，页面不会完全卡死，但仍然会有渲染卡顿的感觉。</p>
<p>优化后，页面仍有卡顿，是因为我们拆分数据的粒度是 1000 条，这种情况下，重新渲染组件仍然有压力，我们观察 fps 只有十几，会有卡顿感。通常只要让页面的 fps 达到 60，页面就会非常流畅，如果我们把数据拆分粒度变成 100 条，基本上 fps 能达到 50 以上，虽然页面渲染变流畅了，但是完成 10000 条数据总的提交时间还是变长了。</p>
<h2 id="8、使用-Non-reactive-data-非响应式数据"><a href="#8、使用-Non-reactive-data-非响应式数据" class="headerlink" title="8、使用 Non-reactive data 非响应式数据"></a>8、使用 Non-reactive data 非响应式数据</h2><p>优化前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">id</span>: uid++,<br>  <span class="hljs-attr">data</span>: item,<br>  <span class="hljs-attr">vote</span>: <span class="hljs-number">0</span>,<br>&#125;));<br></code></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">optimizeItem</span>(item));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">optimizeItem</span>(<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-keyword">const</span> itemData = &#123;<br>    <span class="hljs-attr">id</span>: uid++,<br>    <span class="hljs-attr">vote</span>: <span class="hljs-number">0</span>,<br>  &#125;;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(itemData, <span class="hljs-string">&quot;data&quot;</span>, &#123;<br>    <span class="hljs-comment">// Mark as non-reactive</span><br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: item,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> itemData;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>优化前因为内部提交的数据的时候，会默认把新提交的数据也定义成响应式，如果数据的子属性是对象形式，还会递归让子属性也变成响应式，因此当提交数据很多的时候，这个过程就变成了一个耗时过程。</p>
<p>而优化后我们把新提交的数据中的对象属性 data 手动变成了 configurable 为 false，这样内部在 walk 时通过 Object.keys(obj) 获取对象属性数组会忽略 data，也就不会为 data 这个属性 defineReactive，由于 data 指向的是一个对象，这样也就会减少递归响应式的逻辑，相当于减少了这部分的性能损耗。数据量越大，这种优化的效果就会更明显。</p>
<p>还有一种优化方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scroll</span> = <span class="hljs-literal">null</span>;<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scroll</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BScroll</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们在组件中定义的一些数据，也不一定都要在 data 中定义。有些数据我们并不是用在模板中，也不需要监听它的变化，只是想在组件的上下文中共享这个数据，这个时候我们可以仅仅把这个数据挂载到组件实例 this 上即可，尽管它不是一个响应式对象。</p>
<h2 id="9、使用-Virtual-scrolling-虚拟滚动组件"><a href="#9、使用-Virtual-scrolling-虚拟滚动组件" class="headerlink" title="9、使用 Virtual scrolling 虚拟滚动组件"></a>9、使用 Virtual scrolling 虚拟滚动组件</h2><p>虚拟滚动的实现方式，是只渲染视口内的 DOM，这样总共渲染的 DOM 数量就很少了，自然性能就会好很多。它的基本原理就是监听滚动事件，动态更新需要显示的 DOM 元素，计算出它们在视图中的位移。</p>
<p>虽然一般场景下不会遇到这样的需求，但在特殊场景还是可以作为一个技术优化的手段的。</p>
<h2 id="10、使用-Object-freeze-提升性能"><a href="#10、使用-Object-freeze-提升性能" class="headerlink" title="10、使用 Object.freeze()提升性能"></a>10、使用 Object.freeze()提升性能</h2><p>Object.freeze() 可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。</p>
<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的  data  选项，Vue 将遍历此对象所有的属性，并使用  Object.defineProperty  把这些属性全部转为 getter&#x2F;setter，这些 getter&#x2F;setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>但 Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法。</p>
<p>实际上，使用了 Object.freeze() 之后，减少了 observer 对 cpu 的开销。</p>
<p>由于 Object.freeze() 会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象即可。</p>
<h1 id="五、Webpack-相关优化"><a href="#五、Webpack-相关优化" class="headerlink" title="五、Webpack 相关优化"></a>五、Webpack 相关优化</h1><p>可参考另篇文章<a href="/2023/04/14/webpack%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/#%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96">webpack 实践总结</a>。</p>
<h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6935584878071119885">React 性能优化 | 包括原理、技巧、Demo、工具使用</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6922641008106668045">揭秘 Vue.js 九个性能优化技巧</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#性能优化</a>
      
        <a href="/tags/%E5%AE%9E%E8%B7%B5/">#实践</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>性能优化实践总结</div>
      <div>https://jasonchan27.github.io/2023/08/28/性能优化实践总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jason Chan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月28日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/06/WAF%E5%BC%95%E8%B5%B7%E7%BD%91%E7%BB%9C%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/" title="WAF引起网络链接错误的问题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WAF引起网络链接错误的问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/17/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84React/" title="手写实现自己的React">
                        <span class="hidden-mobile">手写实现自己的React</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"UsaXddA42sfhvk7QGhCaqFp4-gzGzoHsz","appKey":"6VmPvhwsZaqK74sTVXv7PP8K","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a><span>Jason</span></a> <i class="iconfont icon-love"></i> <a><span>Blog</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
